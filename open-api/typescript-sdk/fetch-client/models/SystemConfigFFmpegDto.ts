/* tslint:disable */
/* eslint-disable */
/**
 * Immich
 * Immich API
 *
 * The version of the OpenAPI document: 1.94.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists, mapValues } from '../runtime';
import type { AudioCodec } from './AudioCodec';
import {
    AudioCodecFromJSON,
    AudioCodecFromJSONTyped,
    AudioCodecToJSON,
} from './AudioCodec';
import type { CQMode } from './CQMode';
import {
    CQModeFromJSON,
    CQModeFromJSONTyped,
    CQModeToJSON,
} from './CQMode';
import type { ToneMapping } from './ToneMapping';
import {
    ToneMappingFromJSON,
    ToneMappingFromJSONTyped,
    ToneMappingToJSON,
} from './ToneMapping';
import type { TranscodeHWAccel } from './TranscodeHWAccel';
import {
    TranscodeHWAccelFromJSON,
    TranscodeHWAccelFromJSONTyped,
    TranscodeHWAccelToJSON,
} from './TranscodeHWAccel';
import type { TranscodePolicy } from './TranscodePolicy';
import {
    TranscodePolicyFromJSON,
    TranscodePolicyFromJSONTyped,
    TranscodePolicyToJSON,
} from './TranscodePolicy';
import type { VideoCodec } from './VideoCodec';
import {
    VideoCodecFromJSON,
    VideoCodecFromJSONTyped,
    VideoCodecToJSON,
} from './VideoCodec';

/**
 * 
 * @export
 * @interface SystemConfigFFmpegDto
 */
export interface SystemConfigFFmpegDto {
    /**
     * 
     * @type {TranscodeHWAccel}
     * @memberof SystemConfigFFmpegDto
     */
    accel: TranscodeHWAccel;
    /**
     * 
     * @type {Array<AudioCodec>}
     * @memberof SystemConfigFFmpegDto
     */
    acceptedAudioCodecs: Array<AudioCodec>;
    /**
     * 
     * @type {Array<VideoCodec>}
     * @memberof SystemConfigFFmpegDto
     */
    acceptedVideoCodecs: Array<VideoCodec>;
    /**
     * 
     * @type {number}
     * @memberof SystemConfigFFmpegDto
     */
    bframes: number;
    /**
     * 
     * @type {CQMode}
     * @memberof SystemConfigFFmpegDto
     */
    cqMode: CQMode;
    /**
     * 
     * @type {number}
     * @memberof SystemConfigFFmpegDto
     */
    crf: number;
    /**
     * 
     * @type {number}
     * @memberof SystemConfigFFmpegDto
     */
    gopSize: number;
    /**
     * 
     * @type {string}
     * @memberof SystemConfigFFmpegDto
     */
    maxBitrate: string;
    /**
     * 
     * @type {number}
     * @memberof SystemConfigFFmpegDto
     */
    npl: number;
    /**
     * 
     * @type {string}
     * @memberof SystemConfigFFmpegDto
     */
    preferredHwDevice: string;
    /**
     * 
     * @type {string}
     * @memberof SystemConfigFFmpegDto
     */
    preset: string;
    /**
     * 
     * @type {number}
     * @memberof SystemConfigFFmpegDto
     */
    refs: number;
    /**
     * 
     * @type {AudioCodec}
     * @memberof SystemConfigFFmpegDto
     */
    targetAudioCodec: AudioCodec;
    /**
     * 
     * @type {string}
     * @memberof SystemConfigFFmpegDto
     */
    targetResolution: string;
    /**
     * 
     * @type {VideoCodec}
     * @memberof SystemConfigFFmpegDto
     */
    targetVideoCodec: VideoCodec;
    /**
     * 
     * @type {boolean}
     * @memberof SystemConfigFFmpegDto
     */
    temporalAQ: boolean;
    /**
     * 
     * @type {number}
     * @memberof SystemConfigFFmpegDto
     */
    threads: number;
    /**
     * 
     * @type {ToneMapping}
     * @memberof SystemConfigFFmpegDto
     */
    tonemap: ToneMapping;
    /**
     * 
     * @type {TranscodePolicy}
     * @memberof SystemConfigFFmpegDto
     */
    transcode: TranscodePolicy;
    /**
     * 
     * @type {boolean}
     * @memberof SystemConfigFFmpegDto
     */
    twoPass: boolean;
}

/**
 * Check if a given object implements the SystemConfigFFmpegDto interface.
 */
export function instanceOfSystemConfigFFmpegDto(value: object): boolean {
    let isInstance = true;
    isInstance = isInstance && "accel" in value;
    isInstance = isInstance && "acceptedAudioCodecs" in value;
    isInstance = isInstance && "acceptedVideoCodecs" in value;
    isInstance = isInstance && "bframes" in value;
    isInstance = isInstance && "cqMode" in value;
    isInstance = isInstance && "crf" in value;
    isInstance = isInstance && "gopSize" in value;
    isInstance = isInstance && "maxBitrate" in value;
    isInstance = isInstance && "npl" in value;
    isInstance = isInstance && "preferredHwDevice" in value;
    isInstance = isInstance && "preset" in value;
    isInstance = isInstance && "refs" in value;
    isInstance = isInstance && "targetAudioCodec" in value;
    isInstance = isInstance && "targetResolution" in value;
    isInstance = isInstance && "targetVideoCodec" in value;
    isInstance = isInstance && "temporalAQ" in value;
    isInstance = isInstance && "threads" in value;
    isInstance = isInstance && "tonemap" in value;
    isInstance = isInstance && "transcode" in value;
    isInstance = isInstance && "twoPass" in value;

    return isInstance;
}

export function SystemConfigFFmpegDtoFromJSON(json: any): SystemConfigFFmpegDto {
    return SystemConfigFFmpegDtoFromJSONTyped(json, false);
}

export function SystemConfigFFmpegDtoFromJSONTyped(json: any, ignoreDiscriminator: boolean): SystemConfigFFmpegDto {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        
        'accel': TranscodeHWAccelFromJSON(json['accel']),
        'acceptedAudioCodecs': ((json['acceptedAudioCodecs'] as Array<any>).map(AudioCodecFromJSON)),
        'acceptedVideoCodecs': ((json['acceptedVideoCodecs'] as Array<any>).map(VideoCodecFromJSON)),
        'bframes': json['bframes'],
        'cqMode': CQModeFromJSON(json['cqMode']),
        'crf': json['crf'],
        'gopSize': json['gopSize'],
        'maxBitrate': json['maxBitrate'],
        'npl': json['npl'],
        'preferredHwDevice': json['preferredHwDevice'],
        'preset': json['preset'],
        'refs': json['refs'],
        'targetAudioCodec': AudioCodecFromJSON(json['targetAudioCodec']),
        'targetResolution': json['targetResolution'],
        'targetVideoCodec': VideoCodecFromJSON(json['targetVideoCodec']),
        'temporalAQ': json['temporalAQ'],
        'threads': json['threads'],
        'tonemap': ToneMappingFromJSON(json['tonemap']),
        'transcode': TranscodePolicyFromJSON(json['transcode']),
        'twoPass': json['twoPass'],
    };
}

export function SystemConfigFFmpegDtoToJSON(value?: SystemConfigFFmpegDto | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        
        'accel': TranscodeHWAccelToJSON(value.accel),
        'acceptedAudioCodecs': ((value.acceptedAudioCodecs as Array<any>).map(AudioCodecToJSON)),
        'acceptedVideoCodecs': ((value.acceptedVideoCodecs as Array<any>).map(VideoCodecToJSON)),
        'bframes': value.bframes,
        'cqMode': CQModeToJSON(value.cqMode),
        'crf': value.crf,
        'gopSize': value.gopSize,
        'maxBitrate': value.maxBitrate,
        'npl': value.npl,
        'preferredHwDevice': value.preferredHwDevice,
        'preset': value.preset,
        'refs': value.refs,
        'targetAudioCodec': AudioCodecToJSON(value.targetAudioCodec),
        'targetResolution': value.targetResolution,
        'targetVideoCodec': VideoCodecToJSON(value.targetVideoCodec),
        'temporalAQ': value.temporalAQ,
        'threads': value.threads,
        'tonemap': ToneMappingToJSON(value.tonemap),
        'transcode': TranscodePolicyToJSON(value.transcode),
        'twoPass': value.twoPass,
    };
}

