/* tslint:disable */
/* eslint-disable */
/**
 * Immich
 * Immich API
 *
 * The version of the OpenAPI document: 1.94.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AssetBulkDeleteDto,
  AssetBulkUpdateDto,
  AssetBulkUploadCheckDto,
  AssetBulkUploadCheckResponseDto,
  AssetFileUploadResponseDto,
  AssetIdsDto,
  AssetJobsDto,
  AssetOrder,
  AssetResponseDto,
  AssetStatsResponseDto,
  AssetTypeEnum,
  BulkIdsDto,
  CheckExistingAssetsDto,
  CheckExistingAssetsResponseDto,
  CuratedLocationsResponseDto,
  CuratedObjectsResponseDto,
  DownloadInfoDto,
  DownloadResponseDto,
  MapMarkerResponseDto,
  MemoryLaneResponseDto,
  ThumbnailFormat,
  TimeBucketResponseDto,
  TimeBucketSize,
  UpdateAssetDto,
  UpdateStackParentDto,
} from '../models/index';
import {
    AssetBulkDeleteDtoFromJSON,
    AssetBulkDeleteDtoToJSON,
    AssetBulkUpdateDtoFromJSON,
    AssetBulkUpdateDtoToJSON,
    AssetBulkUploadCheckDtoFromJSON,
    AssetBulkUploadCheckDtoToJSON,
    AssetBulkUploadCheckResponseDtoFromJSON,
    AssetBulkUploadCheckResponseDtoToJSON,
    AssetFileUploadResponseDtoFromJSON,
    AssetFileUploadResponseDtoToJSON,
    AssetIdsDtoFromJSON,
    AssetIdsDtoToJSON,
    AssetJobsDtoFromJSON,
    AssetJobsDtoToJSON,
    AssetOrderFromJSON,
    AssetOrderToJSON,
    AssetResponseDtoFromJSON,
    AssetResponseDtoToJSON,
    AssetStatsResponseDtoFromJSON,
    AssetStatsResponseDtoToJSON,
    AssetTypeEnumFromJSON,
    AssetTypeEnumToJSON,
    BulkIdsDtoFromJSON,
    BulkIdsDtoToJSON,
    CheckExistingAssetsDtoFromJSON,
    CheckExistingAssetsDtoToJSON,
    CheckExistingAssetsResponseDtoFromJSON,
    CheckExistingAssetsResponseDtoToJSON,
    CuratedLocationsResponseDtoFromJSON,
    CuratedLocationsResponseDtoToJSON,
    CuratedObjectsResponseDtoFromJSON,
    CuratedObjectsResponseDtoToJSON,
    DownloadInfoDtoFromJSON,
    DownloadInfoDtoToJSON,
    DownloadResponseDtoFromJSON,
    DownloadResponseDtoToJSON,
    MapMarkerResponseDtoFromJSON,
    MapMarkerResponseDtoToJSON,
    MemoryLaneResponseDtoFromJSON,
    MemoryLaneResponseDtoToJSON,
    ThumbnailFormatFromJSON,
    ThumbnailFormatToJSON,
    TimeBucketResponseDtoFromJSON,
    TimeBucketResponseDtoToJSON,
    TimeBucketSizeFromJSON,
    TimeBucketSizeToJSON,
    UpdateAssetDtoFromJSON,
    UpdateAssetDtoToJSON,
    UpdateStackParentDtoFromJSON,
    UpdateStackParentDtoToJSON,
} from '../models/index';

export interface CheckBulkUploadRequest {
    assetBulkUploadCheckDto: AssetBulkUploadCheckDto;
}

export interface CheckExistingAssetsRequest {
    checkExistingAssetsDto: CheckExistingAssetsDto;
}

export interface DeleteAssetsRequest {
    assetBulkDeleteDto: AssetBulkDeleteDto;
}

export interface DownloadArchiveOldRequest {
    assetIdsDto: AssetIdsDto;
    key?: string;
}

export interface DownloadFileOldRequest {
    id: string;
    key?: string;
}

export interface GetAllAssetsRequest {
    ifNoneMatch?: string;
    isArchived?: boolean;
    isFavorite?: boolean;
    skip?: number;
    take?: number;
    updatedAfter?: Date;
    updatedBefore?: Date;
    userId?: string;
}

export interface GetAllUserAssetsByDeviceIdRequest {
    deviceId: string;
}

export interface GetAssetByIdRequest {
    id: string;
    key?: string;
}

export interface GetAssetInfoRequest {
    id: string;
    key?: string;
}

export interface GetAssetStatisticsRequest {
    isArchived?: boolean;
    isFavorite?: boolean;
    isTrashed?: boolean;
}

export interface GetAssetThumbnailRequest {
    id: string;
    format?: ThumbnailFormat;
    key?: string;
}

export interface GetDownloadInfoOldRequest {
    downloadInfoDto: DownloadInfoDto;
    key?: string;
}

export interface GetMapMarkersRequest {
    fileCreatedAfter?: Date;
    fileCreatedBefore?: Date;
    isArchived?: boolean;
    isFavorite?: boolean;
}

export interface GetMemoryLaneRequest {
    day: number;
    month: number;
}

export interface GetRandomRequest {
    count?: number;
}

export interface GetTimeBucketRequest {
    size: TimeBucketSize;
    timeBucket: string;
    albumId?: string;
    isArchived?: boolean;
    isFavorite?: boolean;
    isTrashed?: boolean;
    key?: string;
    personId?: string;
    userId?: string;
    withPartners?: boolean;
    withStacked?: boolean;
}

export interface GetTimeBucketsRequest {
    size: TimeBucketSize;
    albumId?: string;
    isArchived?: boolean;
    isFavorite?: boolean;
    isTrashed?: boolean;
    key?: string;
    personId?: string;
    userId?: string;
    withPartners?: boolean;
    withStacked?: boolean;
}

export interface RestoreAssetsOldRequest {
    bulkIdsDto: BulkIdsDto;
}

export interface RunAssetJobsRequest {
    assetJobsDto: AssetJobsDto;
}

export interface SearchAssetsRequest {
    checksum?: string;
    city?: string;
    country?: string;
    createdAfter?: Date;
    createdBefore?: Date;
    deviceAssetId?: string;
    deviceId?: string;
    encodedVideoPath?: string;
    id?: string;
    isArchived?: boolean;
    isEncoded?: boolean;
    isExternal?: boolean;
    isFavorite?: boolean;
    isMotion?: boolean;
    isOffline?: boolean;
    isReadOnly?: boolean;
    isVisible?: boolean;
    lensModel?: string;
    libraryId?: string;
    make?: string;
    model?: string;
    order?: AssetOrder;
    originalFileName?: string;
    originalPath?: string;
    page?: number;
    resizePath?: string;
    size?: number;
    state?: string;
    takenAfter?: Date;
    takenBefore?: Date;
    trashedAfter?: Date;
    trashedBefore?: Date;
    type?: AssetTypeEnum;
    updatedAfter?: Date;
    updatedBefore?: Date;
    webpPath?: string;
    withDeleted?: boolean;
    withExif?: boolean;
    withPeople?: boolean;
    withStacked?: boolean;
}

export interface ServeFileRequest {
    id: string;
    isThumb?: boolean;
    isWeb?: boolean;
    key?: string;
}

export interface UpdateAssetRequest {
    id: string;
    updateAssetDto: UpdateAssetDto;
}

export interface UpdateAssetsRequest {
    assetBulkUpdateDto: AssetBulkUpdateDto;
}

export interface UpdateStackParentRequest {
    updateStackParentDto: UpdateStackParentDto;
}

export interface UploadFileRequest {
    assetData: Blob;
    deviceAssetId: string;
    deviceId: string;
    fileCreatedAt: Date;
    fileModifiedAt: Date;
    key?: string;
    duration?: string;
    isArchived?: boolean;
    isExternal?: boolean;
    isFavorite?: boolean;
    isOffline?: boolean;
    isReadOnly?: boolean;
    isVisible?: boolean;
    libraryId?: string;
    livePhotoData?: Blob;
    sidecarData?: Blob;
}

/**
 * 
 */
export class AssetApi extends runtime.BaseAPI {

    /**
     * Checks if assets exist by checksums
     */
    async checkBulkUploadRaw(requestParameters: CheckBulkUploadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AssetBulkUploadCheckResponseDto>> {
        if (requestParameters.assetBulkUploadCheckDto === null || requestParameters.assetBulkUploadCheckDto === undefined) {
            throw new runtime.RequiredError('assetBulkUploadCheckDto','Required parameter requestParameters.assetBulkUploadCheckDto was null or undefined when calling checkBulkUpload.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = this.configuration.apiKey("x-api-key"); // api_key authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/asset/bulk-upload-check`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AssetBulkUploadCheckDtoToJSON(requestParameters.assetBulkUploadCheckDto),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AssetBulkUploadCheckResponseDtoFromJSON(jsonValue));
    }

    /**
     * Checks if assets exist by checksums
     */
    async checkBulkUpload(requestParameters: CheckBulkUploadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AssetBulkUploadCheckResponseDto> {
        const response = await this.checkBulkUploadRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Checks if multiple assets exist on the server and returns all existing - used by background backup
     */
    async checkExistingAssetsRaw(requestParameters: CheckExistingAssetsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CheckExistingAssetsResponseDto>> {
        if (requestParameters.checkExistingAssetsDto === null || requestParameters.checkExistingAssetsDto === undefined) {
            throw new runtime.RequiredError('checkExistingAssetsDto','Required parameter requestParameters.checkExistingAssetsDto was null or undefined when calling checkExistingAssets.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = this.configuration.apiKey("x-api-key"); // api_key authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/asset/exist`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CheckExistingAssetsDtoToJSON(requestParameters.checkExistingAssetsDto),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CheckExistingAssetsResponseDtoFromJSON(jsonValue));
    }

    /**
     * Checks if multiple assets exist on the server and returns all existing - used by background backup
     */
    async checkExistingAssets(requestParameters: CheckExistingAssetsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CheckExistingAssetsResponseDto> {
        const response = await this.checkExistingAssetsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async deleteAssetsRaw(requestParameters: DeleteAssetsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.assetBulkDeleteDto === null || requestParameters.assetBulkDeleteDto === undefined) {
            throw new runtime.RequiredError('assetBulkDeleteDto','Required parameter requestParameters.assetBulkDeleteDto was null or undefined when calling deleteAssets.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = this.configuration.apiKey("x-api-key"); // api_key authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/asset`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: AssetBulkDeleteDtoToJSON(requestParameters.assetBulkDeleteDto),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async deleteAssets(requestParameters: DeleteAssetsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteAssetsRaw(requestParameters, initOverrides);
    }

    /**
     */
    async downloadArchiveOldRaw(requestParameters: DownloadArchiveOldRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters.assetIdsDto === null || requestParameters.assetIdsDto === undefined) {
            throw new runtime.RequiredError('assetIdsDto','Required parameter requestParameters.assetIdsDto was null or undefined when calling downloadArchiveOld.');
        }

        const queryParameters: any = {};

        if (requestParameters.key !== undefined) {
            queryParameters['key'] = requestParameters.key;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = this.configuration.apiKey("x-api-key"); // api_key authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/asset/download/archive`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AssetIdsDtoToJSON(requestParameters.assetIdsDto),
        }, initOverrides);

        return new runtime.BlobApiResponse(response);
    }

    /**
     */
    async downloadArchiveOld(requestParameters: DownloadArchiveOldRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Blob> {
        const response = await this.downloadArchiveOldRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async downloadFileOldRaw(requestParameters: DownloadFileOldRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling downloadFileOld.');
        }

        const queryParameters: any = {};

        if (requestParameters.key !== undefined) {
            queryParameters['key'] = requestParameters.key;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = this.configuration.apiKey("x-api-key"); // api_key authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/asset/download/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.BlobApiResponse(response);
    }

    /**
     */
    async downloadFileOld(requestParameters: DownloadFileOldRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Blob> {
        const response = await this.downloadFileOldRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async emptyTrashOldRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = this.configuration.apiKey("x-api-key"); // api_key authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/asset/trash/empty`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async emptyTrashOld(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.emptyTrashOldRaw(initOverrides);
    }

    /**
     * Get all AssetEntity belong to the user
     */
    async getAllAssetsRaw(requestParameters: GetAllAssetsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<AssetResponseDto>>> {
        const queryParameters: any = {};

        if (requestParameters.isArchived !== undefined) {
            queryParameters['isArchived'] = requestParameters.isArchived;
        }

        if (requestParameters.isFavorite !== undefined) {
            queryParameters['isFavorite'] = requestParameters.isFavorite;
        }

        if (requestParameters.skip !== undefined) {
            queryParameters['skip'] = requestParameters.skip;
        }

        if (requestParameters.take !== undefined) {
            queryParameters['take'] = requestParameters.take;
        }

        if (requestParameters.updatedAfter !== undefined) {
            queryParameters['updatedAfter'] = (requestParameters.updatedAfter as any).toISOString();
        }

        if (requestParameters.updatedBefore !== undefined) {
            queryParameters['updatedBefore'] = (requestParameters.updatedBefore as any).toISOString();
        }

        if (requestParameters.userId !== undefined) {
            queryParameters['userId'] = requestParameters.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.ifNoneMatch !== undefined && requestParameters.ifNoneMatch !== null) {
            headerParameters['if-none-match'] = String(requestParameters.ifNoneMatch);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = this.configuration.apiKey("x-api-key"); // api_key authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/asset`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AssetResponseDtoFromJSON));
    }

    /**
     * Get all AssetEntity belong to the user
     */
    async getAllAssets(requestParameters: GetAllAssetsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<AssetResponseDto>> {
        const response = await this.getAllAssetsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get all asset of a device that are in the database, ID only.
     */
    async getAllUserAssetsByDeviceIdRaw(requestParameters: GetAllUserAssetsByDeviceIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<string>>> {
        if (requestParameters.deviceId === null || requestParameters.deviceId === undefined) {
            throw new runtime.RequiredError('deviceId','Required parameter requestParameters.deviceId was null or undefined when calling getAllUserAssetsByDeviceId.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = this.configuration.apiKey("x-api-key"); // api_key authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/asset/device/{deviceId}`.replace(`{${"deviceId"}}`, encodeURIComponent(String(requestParameters.deviceId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Get all asset of a device that are in the database, ID only.
     */
    async getAllUserAssetsByDeviceId(requestParameters: GetAllUserAssetsByDeviceIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<string>> {
        const response = await this.getAllUserAssetsByDeviceIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a single asset\'s information
     * @deprecated
     */
    async getAssetByIdRaw(requestParameters: GetAssetByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AssetResponseDto>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getAssetById.');
        }

        const queryParameters: any = {};

        if (requestParameters.key !== undefined) {
            queryParameters['key'] = requestParameters.key;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = this.configuration.apiKey("x-api-key"); // api_key authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/asset/assetById/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AssetResponseDtoFromJSON(jsonValue));
    }

    /**
     * Get a single asset\'s information
     * @deprecated
     */
    async getAssetById(requestParameters: GetAssetByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AssetResponseDto> {
        const response = await this.getAssetByIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async getAssetInfoRaw(requestParameters: GetAssetInfoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AssetResponseDto>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getAssetInfo.');
        }

        const queryParameters: any = {};

        if (requestParameters.key !== undefined) {
            queryParameters['key'] = requestParameters.key;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = this.configuration.apiKey("x-api-key"); // api_key authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/asset/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AssetResponseDtoFromJSON(jsonValue));
    }

    /**
     */
    async getAssetInfo(requestParameters: GetAssetInfoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AssetResponseDto> {
        const response = await this.getAssetInfoRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async getAssetSearchTermsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<string>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = this.configuration.apiKey("x-api-key"); // api_key authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/asset/search-terms`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     */
    async getAssetSearchTerms(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<string>> {
        const response = await this.getAssetSearchTermsRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async getAssetStatisticsRaw(requestParameters: GetAssetStatisticsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AssetStatsResponseDto>> {
        const queryParameters: any = {};

        if (requestParameters.isArchived !== undefined) {
            queryParameters['isArchived'] = requestParameters.isArchived;
        }

        if (requestParameters.isFavorite !== undefined) {
            queryParameters['isFavorite'] = requestParameters.isFavorite;
        }

        if (requestParameters.isTrashed !== undefined) {
            queryParameters['isTrashed'] = requestParameters.isTrashed;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = this.configuration.apiKey("x-api-key"); // api_key authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/asset/statistics`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AssetStatsResponseDtoFromJSON(jsonValue));
    }

    /**
     */
    async getAssetStatistics(requestParameters: GetAssetStatisticsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AssetStatsResponseDto> {
        const response = await this.getAssetStatisticsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async getAssetThumbnailRaw(requestParameters: GetAssetThumbnailRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getAssetThumbnail.');
        }

        const queryParameters: any = {};

        if (requestParameters.format !== undefined) {
            queryParameters['format'] = requestParameters.format;
        }

        if (requestParameters.key !== undefined) {
            queryParameters['key'] = requestParameters.key;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = this.configuration.apiKey("x-api-key"); // api_key authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/asset/thumbnail/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.BlobApiResponse(response);
    }

    /**
     */
    async getAssetThumbnail(requestParameters: GetAssetThumbnailRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Blob> {
        const response = await this.getAssetThumbnailRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async getCuratedLocationsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<CuratedLocationsResponseDto>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = this.configuration.apiKey("x-api-key"); // api_key authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/asset/curated-locations`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CuratedLocationsResponseDtoFromJSON));
    }

    /**
     */
    async getCuratedLocations(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<CuratedLocationsResponseDto>> {
        const response = await this.getCuratedLocationsRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async getCuratedObjectsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<CuratedObjectsResponseDto>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = this.configuration.apiKey("x-api-key"); // api_key authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/asset/curated-objects`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CuratedObjectsResponseDtoFromJSON));
    }

    /**
     */
    async getCuratedObjects(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<CuratedObjectsResponseDto>> {
        const response = await this.getCuratedObjectsRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async getDownloadInfoOldRaw(requestParameters: GetDownloadInfoOldRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DownloadResponseDto>> {
        if (requestParameters.downloadInfoDto === null || requestParameters.downloadInfoDto === undefined) {
            throw new runtime.RequiredError('downloadInfoDto','Required parameter requestParameters.downloadInfoDto was null or undefined when calling getDownloadInfoOld.');
        }

        const queryParameters: any = {};

        if (requestParameters.key !== undefined) {
            queryParameters['key'] = requestParameters.key;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = this.configuration.apiKey("x-api-key"); // api_key authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/asset/download/info`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: DownloadInfoDtoToJSON(requestParameters.downloadInfoDto),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DownloadResponseDtoFromJSON(jsonValue));
    }

    /**
     */
    async getDownloadInfoOld(requestParameters: GetDownloadInfoOldRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DownloadResponseDto> {
        const response = await this.getDownloadInfoOldRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async getMapMarkersRaw(requestParameters: GetMapMarkersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<MapMarkerResponseDto>>> {
        const queryParameters: any = {};

        if (requestParameters.fileCreatedAfter !== undefined) {
            queryParameters['fileCreatedAfter'] = (requestParameters.fileCreatedAfter as any).toISOString();
        }

        if (requestParameters.fileCreatedBefore !== undefined) {
            queryParameters['fileCreatedBefore'] = (requestParameters.fileCreatedBefore as any).toISOString();
        }

        if (requestParameters.isArchived !== undefined) {
            queryParameters['isArchived'] = requestParameters.isArchived;
        }

        if (requestParameters.isFavorite !== undefined) {
            queryParameters['isFavorite'] = requestParameters.isFavorite;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = this.configuration.apiKey("x-api-key"); // api_key authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/asset/map-marker`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(MapMarkerResponseDtoFromJSON));
    }

    /**
     */
    async getMapMarkers(requestParameters: GetMapMarkersRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<MapMarkerResponseDto>> {
        const response = await this.getMapMarkersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async getMemoryLaneRaw(requestParameters: GetMemoryLaneRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<MemoryLaneResponseDto>>> {
        if (requestParameters.day === null || requestParameters.day === undefined) {
            throw new runtime.RequiredError('day','Required parameter requestParameters.day was null or undefined when calling getMemoryLane.');
        }

        if (requestParameters.month === null || requestParameters.month === undefined) {
            throw new runtime.RequiredError('month','Required parameter requestParameters.month was null or undefined when calling getMemoryLane.');
        }

        const queryParameters: any = {};

        if (requestParameters.day !== undefined) {
            queryParameters['day'] = requestParameters.day;
        }

        if (requestParameters.month !== undefined) {
            queryParameters['month'] = requestParameters.month;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = this.configuration.apiKey("x-api-key"); // api_key authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/asset/memory-lane`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(MemoryLaneResponseDtoFromJSON));
    }

    /**
     */
    async getMemoryLane(requestParameters: GetMemoryLaneRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<MemoryLaneResponseDto>> {
        const response = await this.getMemoryLaneRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async getRandomRaw(requestParameters: GetRandomRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<AssetResponseDto>>> {
        const queryParameters: any = {};

        if (requestParameters.count !== undefined) {
            queryParameters['count'] = requestParameters.count;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = this.configuration.apiKey("x-api-key"); // api_key authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/asset/random`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AssetResponseDtoFromJSON));
    }

    /**
     */
    async getRandom(requestParameters: GetRandomRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<AssetResponseDto>> {
        const response = await this.getRandomRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async getTimeBucketRaw(requestParameters: GetTimeBucketRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<AssetResponseDto>>> {
        if (requestParameters.size === null || requestParameters.size === undefined) {
            throw new runtime.RequiredError('size','Required parameter requestParameters.size was null or undefined when calling getTimeBucket.');
        }

        if (requestParameters.timeBucket === null || requestParameters.timeBucket === undefined) {
            throw new runtime.RequiredError('timeBucket','Required parameter requestParameters.timeBucket was null or undefined when calling getTimeBucket.');
        }

        const queryParameters: any = {};

        if (requestParameters.albumId !== undefined) {
            queryParameters['albumId'] = requestParameters.albumId;
        }

        if (requestParameters.isArchived !== undefined) {
            queryParameters['isArchived'] = requestParameters.isArchived;
        }

        if (requestParameters.isFavorite !== undefined) {
            queryParameters['isFavorite'] = requestParameters.isFavorite;
        }

        if (requestParameters.isTrashed !== undefined) {
            queryParameters['isTrashed'] = requestParameters.isTrashed;
        }

        if (requestParameters.key !== undefined) {
            queryParameters['key'] = requestParameters.key;
        }

        if (requestParameters.personId !== undefined) {
            queryParameters['personId'] = requestParameters.personId;
        }

        if (requestParameters.size !== undefined) {
            queryParameters['size'] = requestParameters.size;
        }

        if (requestParameters.timeBucket !== undefined) {
            queryParameters['timeBucket'] = requestParameters.timeBucket;
        }

        if (requestParameters.userId !== undefined) {
            queryParameters['userId'] = requestParameters.userId;
        }

        if (requestParameters.withPartners !== undefined) {
            queryParameters['withPartners'] = requestParameters.withPartners;
        }

        if (requestParameters.withStacked !== undefined) {
            queryParameters['withStacked'] = requestParameters.withStacked;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = this.configuration.apiKey("x-api-key"); // api_key authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/asset/time-bucket`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AssetResponseDtoFromJSON));
    }

    /**
     */
    async getTimeBucket(requestParameters: GetTimeBucketRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<AssetResponseDto>> {
        const response = await this.getTimeBucketRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async getTimeBucketsRaw(requestParameters: GetTimeBucketsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<TimeBucketResponseDto>>> {
        if (requestParameters.size === null || requestParameters.size === undefined) {
            throw new runtime.RequiredError('size','Required parameter requestParameters.size was null or undefined when calling getTimeBuckets.');
        }

        const queryParameters: any = {};

        if (requestParameters.albumId !== undefined) {
            queryParameters['albumId'] = requestParameters.albumId;
        }

        if (requestParameters.isArchived !== undefined) {
            queryParameters['isArchived'] = requestParameters.isArchived;
        }

        if (requestParameters.isFavorite !== undefined) {
            queryParameters['isFavorite'] = requestParameters.isFavorite;
        }

        if (requestParameters.isTrashed !== undefined) {
            queryParameters['isTrashed'] = requestParameters.isTrashed;
        }

        if (requestParameters.key !== undefined) {
            queryParameters['key'] = requestParameters.key;
        }

        if (requestParameters.personId !== undefined) {
            queryParameters['personId'] = requestParameters.personId;
        }

        if (requestParameters.size !== undefined) {
            queryParameters['size'] = requestParameters.size;
        }

        if (requestParameters.userId !== undefined) {
            queryParameters['userId'] = requestParameters.userId;
        }

        if (requestParameters.withPartners !== undefined) {
            queryParameters['withPartners'] = requestParameters.withPartners;
        }

        if (requestParameters.withStacked !== undefined) {
            queryParameters['withStacked'] = requestParameters.withStacked;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = this.configuration.apiKey("x-api-key"); // api_key authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/asset/time-buckets`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TimeBucketResponseDtoFromJSON));
    }

    /**
     */
    async getTimeBuckets(requestParameters: GetTimeBucketsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<TimeBucketResponseDto>> {
        const response = await this.getTimeBucketsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async restoreAssetsOldRaw(requestParameters: RestoreAssetsOldRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.bulkIdsDto === null || requestParameters.bulkIdsDto === undefined) {
            throw new runtime.RequiredError('bulkIdsDto','Required parameter requestParameters.bulkIdsDto was null or undefined when calling restoreAssetsOld.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = this.configuration.apiKey("x-api-key"); // api_key authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/asset/restore`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BulkIdsDtoToJSON(requestParameters.bulkIdsDto),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async restoreAssetsOld(requestParameters: RestoreAssetsOldRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.restoreAssetsOldRaw(requestParameters, initOverrides);
    }

    /**
     */
    async restoreTrashOldRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = this.configuration.apiKey("x-api-key"); // api_key authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/asset/trash/restore`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async restoreTrashOld(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.restoreTrashOldRaw(initOverrides);
    }

    /**
     */
    async runAssetJobsRaw(requestParameters: RunAssetJobsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.assetJobsDto === null || requestParameters.assetJobsDto === undefined) {
            throw new runtime.RequiredError('assetJobsDto','Required parameter requestParameters.assetJobsDto was null or undefined when calling runAssetJobs.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = this.configuration.apiKey("x-api-key"); // api_key authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/asset/jobs`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AssetJobsDtoToJSON(requestParameters.assetJobsDto),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async runAssetJobs(requestParameters: RunAssetJobsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.runAssetJobsRaw(requestParameters, initOverrides);
    }

    /**
     */
    async searchAssetsRaw(requestParameters: SearchAssetsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<AssetResponseDto>>> {
        const queryParameters: any = {};

        if (requestParameters.checksum !== undefined) {
            queryParameters['checksum'] = requestParameters.checksum;
        }

        if (requestParameters.city !== undefined) {
            queryParameters['city'] = requestParameters.city;
        }

        if (requestParameters.country !== undefined) {
            queryParameters['country'] = requestParameters.country;
        }

        if (requestParameters.createdAfter !== undefined) {
            queryParameters['createdAfter'] = (requestParameters.createdAfter as any).toISOString();
        }

        if (requestParameters.createdBefore !== undefined) {
            queryParameters['createdBefore'] = (requestParameters.createdBefore as any).toISOString();
        }

        if (requestParameters.deviceAssetId !== undefined) {
            queryParameters['deviceAssetId'] = requestParameters.deviceAssetId;
        }

        if (requestParameters.deviceId !== undefined) {
            queryParameters['deviceId'] = requestParameters.deviceId;
        }

        if (requestParameters.encodedVideoPath !== undefined) {
            queryParameters['encodedVideoPath'] = requestParameters.encodedVideoPath;
        }

        if (requestParameters.id !== undefined) {
            queryParameters['id'] = requestParameters.id;
        }

        if (requestParameters.isArchived !== undefined) {
            queryParameters['isArchived'] = requestParameters.isArchived;
        }

        if (requestParameters.isEncoded !== undefined) {
            queryParameters['isEncoded'] = requestParameters.isEncoded;
        }

        if (requestParameters.isExternal !== undefined) {
            queryParameters['isExternal'] = requestParameters.isExternal;
        }

        if (requestParameters.isFavorite !== undefined) {
            queryParameters['isFavorite'] = requestParameters.isFavorite;
        }

        if (requestParameters.isMotion !== undefined) {
            queryParameters['isMotion'] = requestParameters.isMotion;
        }

        if (requestParameters.isOffline !== undefined) {
            queryParameters['isOffline'] = requestParameters.isOffline;
        }

        if (requestParameters.isReadOnly !== undefined) {
            queryParameters['isReadOnly'] = requestParameters.isReadOnly;
        }

        if (requestParameters.isVisible !== undefined) {
            queryParameters['isVisible'] = requestParameters.isVisible;
        }

        if (requestParameters.lensModel !== undefined) {
            queryParameters['lensModel'] = requestParameters.lensModel;
        }

        if (requestParameters.libraryId !== undefined) {
            queryParameters['libraryId'] = requestParameters.libraryId;
        }

        if (requestParameters.make !== undefined) {
            queryParameters['make'] = requestParameters.make;
        }

        if (requestParameters.model !== undefined) {
            queryParameters['model'] = requestParameters.model;
        }

        if (requestParameters.order !== undefined) {
            queryParameters['order'] = requestParameters.order;
        }

        if (requestParameters.originalFileName !== undefined) {
            queryParameters['originalFileName'] = requestParameters.originalFileName;
        }

        if (requestParameters.originalPath !== undefined) {
            queryParameters['originalPath'] = requestParameters.originalPath;
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.resizePath !== undefined) {
            queryParameters['resizePath'] = requestParameters.resizePath;
        }

        if (requestParameters.size !== undefined) {
            queryParameters['size'] = requestParameters.size;
        }

        if (requestParameters.state !== undefined) {
            queryParameters['state'] = requestParameters.state;
        }

        if (requestParameters.takenAfter !== undefined) {
            queryParameters['takenAfter'] = (requestParameters.takenAfter as any).toISOString();
        }

        if (requestParameters.takenBefore !== undefined) {
            queryParameters['takenBefore'] = (requestParameters.takenBefore as any).toISOString();
        }

        if (requestParameters.trashedAfter !== undefined) {
            queryParameters['trashedAfter'] = (requestParameters.trashedAfter as any).toISOString();
        }

        if (requestParameters.trashedBefore !== undefined) {
            queryParameters['trashedBefore'] = (requestParameters.trashedBefore as any).toISOString();
        }

        if (requestParameters.type !== undefined) {
            queryParameters['type'] = requestParameters.type;
        }

        if (requestParameters.updatedAfter !== undefined) {
            queryParameters['updatedAfter'] = (requestParameters.updatedAfter as any).toISOString();
        }

        if (requestParameters.updatedBefore !== undefined) {
            queryParameters['updatedBefore'] = (requestParameters.updatedBefore as any).toISOString();
        }

        if (requestParameters.webpPath !== undefined) {
            queryParameters['webpPath'] = requestParameters.webpPath;
        }

        if (requestParameters.withDeleted !== undefined) {
            queryParameters['withDeleted'] = requestParameters.withDeleted;
        }

        if (requestParameters.withExif !== undefined) {
            queryParameters['withExif'] = requestParameters.withExif;
        }

        if (requestParameters.withPeople !== undefined) {
            queryParameters['withPeople'] = requestParameters.withPeople;
        }

        if (requestParameters.withStacked !== undefined) {
            queryParameters['withStacked'] = requestParameters.withStacked;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = this.configuration.apiKey("x-api-key"); // api_key authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/assets`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AssetResponseDtoFromJSON));
    }

    /**
     */
    async searchAssets(requestParameters: SearchAssetsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<AssetResponseDto>> {
        const response = await this.searchAssetsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async serveFileRaw(requestParameters: ServeFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling serveFile.');
        }

        const queryParameters: any = {};

        if (requestParameters.isThumb !== undefined) {
            queryParameters['isThumb'] = requestParameters.isThumb;
        }

        if (requestParameters.isWeb !== undefined) {
            queryParameters['isWeb'] = requestParameters.isWeb;
        }

        if (requestParameters.key !== undefined) {
            queryParameters['key'] = requestParameters.key;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = this.configuration.apiKey("x-api-key"); // api_key authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/asset/file/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.BlobApiResponse(response);
    }

    /**
     */
    async serveFile(requestParameters: ServeFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Blob> {
        const response = await this.serveFileRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async updateAssetRaw(requestParameters: UpdateAssetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AssetResponseDto>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateAsset.');
        }

        if (requestParameters.updateAssetDto === null || requestParameters.updateAssetDto === undefined) {
            throw new runtime.RequiredError('updateAssetDto','Required parameter requestParameters.updateAssetDto was null or undefined when calling updateAsset.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = this.configuration.apiKey("x-api-key"); // api_key authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/asset/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateAssetDtoToJSON(requestParameters.updateAssetDto),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AssetResponseDtoFromJSON(jsonValue));
    }

    /**
     */
    async updateAsset(requestParameters: UpdateAssetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AssetResponseDto> {
        const response = await this.updateAssetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async updateAssetsRaw(requestParameters: UpdateAssetsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.assetBulkUpdateDto === null || requestParameters.assetBulkUpdateDto === undefined) {
            throw new runtime.RequiredError('assetBulkUpdateDto','Required parameter requestParameters.assetBulkUpdateDto was null or undefined when calling updateAssets.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = this.configuration.apiKey("x-api-key"); // api_key authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/asset`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: AssetBulkUpdateDtoToJSON(requestParameters.assetBulkUpdateDto),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async updateAssets(requestParameters: UpdateAssetsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.updateAssetsRaw(requestParameters, initOverrides);
    }

    /**
     */
    async updateStackParentRaw(requestParameters: UpdateStackParentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.updateStackParentDto === null || requestParameters.updateStackParentDto === undefined) {
            throw new runtime.RequiredError('updateStackParentDto','Required parameter requestParameters.updateStackParentDto was null or undefined when calling updateStackParent.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = this.configuration.apiKey("x-api-key"); // api_key authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/asset/stack/parent`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateStackParentDtoToJSON(requestParameters.updateStackParentDto),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async updateStackParent(requestParameters: UpdateStackParentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.updateStackParentRaw(requestParameters, initOverrides);
    }

    /**
     */
    async uploadFileRaw(requestParameters: UploadFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AssetFileUploadResponseDto>> {
        if (requestParameters.assetData === null || requestParameters.assetData === undefined) {
            throw new runtime.RequiredError('assetData','Required parameter requestParameters.assetData was null or undefined when calling uploadFile.');
        }

        if (requestParameters.deviceAssetId === null || requestParameters.deviceAssetId === undefined) {
            throw new runtime.RequiredError('deviceAssetId','Required parameter requestParameters.deviceAssetId was null or undefined when calling uploadFile.');
        }

        if (requestParameters.deviceId === null || requestParameters.deviceId === undefined) {
            throw new runtime.RequiredError('deviceId','Required parameter requestParameters.deviceId was null or undefined when calling uploadFile.');
        }

        if (requestParameters.fileCreatedAt === null || requestParameters.fileCreatedAt === undefined) {
            throw new runtime.RequiredError('fileCreatedAt','Required parameter requestParameters.fileCreatedAt was null or undefined when calling uploadFile.');
        }

        if (requestParameters.fileModifiedAt === null || requestParameters.fileModifiedAt === undefined) {
            throw new runtime.RequiredError('fileModifiedAt','Required parameter requestParameters.fileModifiedAt was null or undefined when calling uploadFile.');
        }

        const queryParameters: any = {};

        if (requestParameters.key !== undefined) {
            queryParameters['key'] = requestParameters.key;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = this.configuration.apiKey("x-api-key"); // api_key authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.assetData !== undefined) {
            formParams.append('assetData', requestParameters.assetData as any);
        }

        if (requestParameters.deviceAssetId !== undefined) {
            formParams.append('deviceAssetId', requestParameters.deviceAssetId as any);
        }

        if (requestParameters.deviceId !== undefined) {
            formParams.append('deviceId', requestParameters.deviceId as any);
        }

        if (requestParameters.duration !== undefined) {
            formParams.append('duration', requestParameters.duration as any);
        }

        if (requestParameters.fileCreatedAt !== undefined) {
            formParams.append('fileCreatedAt', requestParameters.fileCreatedAt as any);
        }

        if (requestParameters.fileModifiedAt !== undefined) {
            formParams.append('fileModifiedAt', requestParameters.fileModifiedAt as any);
        }

        if (requestParameters.isArchived !== undefined) {
            formParams.append('isArchived', requestParameters.isArchived as any);
        }

        if (requestParameters.isExternal !== undefined) {
            formParams.append('isExternal', requestParameters.isExternal as any);
        }

        if (requestParameters.isFavorite !== undefined) {
            formParams.append('isFavorite', requestParameters.isFavorite as any);
        }

        if (requestParameters.isOffline !== undefined) {
            formParams.append('isOffline', requestParameters.isOffline as any);
        }

        if (requestParameters.isReadOnly !== undefined) {
            formParams.append('isReadOnly', requestParameters.isReadOnly as any);
        }

        if (requestParameters.isVisible !== undefined) {
            formParams.append('isVisible', requestParameters.isVisible as any);
        }

        if (requestParameters.libraryId !== undefined) {
            formParams.append('libraryId', requestParameters.libraryId as any);
        }

        if (requestParameters.livePhotoData !== undefined) {
            formParams.append('livePhotoData', requestParameters.livePhotoData as any);
        }

        if (requestParameters.sidecarData !== undefined) {
            formParams.append('sidecarData', requestParameters.sidecarData as any);
        }

        const response = await this.request({
            path: `/asset/upload`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AssetFileUploadResponseDtoFromJSON(jsonValue));
    }

    /**
     */
    async uploadFile(requestParameters: UploadFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AssetFileUploadResponseDto> {
        const response = await this.uploadFileRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
