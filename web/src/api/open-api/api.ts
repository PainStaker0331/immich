/* tslint:disable */
/* eslint-disable */
/**
 * Immich
 * Immich API
 *
 * The version of the OpenAPI document: 1.39.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AddAssetsDto
 */
export interface AddAssetsDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof AddAssetsDto
     */
    'assetIds': Array<string>;
}
/**
 * 
 * @export
 * @interface AddAssetsResponseDto
 */
export interface AddAssetsResponseDto {
    /**
     * 
     * @type {number}
     * @memberof AddAssetsResponseDto
     */
    'successfullyAdded': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof AddAssetsResponseDto
     */
    'alreadyInAlbum': Array<string>;
    /**
     * 
     * @type {AlbumResponseDto}
     * @memberof AddAssetsResponseDto
     */
    'album'?: AlbumResponseDto;
}
/**
 * 
 * @export
 * @interface AddUsersDto
 */
export interface AddUsersDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof AddUsersDto
     */
    'sharedUserIds': Array<string>;
}
/**
 * 
 * @export
 * @interface AdminSignupResponseDto
 */
export interface AdminSignupResponseDto {
    /**
     * 
     * @type {string}
     * @memberof AdminSignupResponseDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AdminSignupResponseDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof AdminSignupResponseDto
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof AdminSignupResponseDto
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof AdminSignupResponseDto
     */
    'createdAt': string;
}
/**
 * 
 * @export
 * @interface AlbumCountResponseDto
 */
export interface AlbumCountResponseDto {
    /**
     * 
     * @type {number}
     * @memberof AlbumCountResponseDto
     */
    'owned': number;
    /**
     * 
     * @type {number}
     * @memberof AlbumCountResponseDto
     */
    'shared': number;
    /**
     * 
     * @type {number}
     * @memberof AlbumCountResponseDto
     */
    'sharing': number;
}
/**
 * 
 * @export
 * @interface AlbumResponseDto
 */
export interface AlbumResponseDto {
    /**
     * 
     * @type {number}
     * @memberof AlbumResponseDto
     */
    'assetCount': number;
    /**
     * 
     * @type {string}
     * @memberof AlbumResponseDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AlbumResponseDto
     */
    'ownerId': string;
    /**
     * 
     * @type {string}
     * @memberof AlbumResponseDto
     */
    'albumName': string;
    /**
     * 
     * @type {string}
     * @memberof AlbumResponseDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof AlbumResponseDto
     */
    'albumThumbnailAssetId': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof AlbumResponseDto
     */
    'shared': boolean;
    /**
     * 
     * @type {Array<UserResponseDto>}
     * @memberof AlbumResponseDto
     */
    'sharedUsers': Array<UserResponseDto>;
    /**
     * 
     * @type {Array<AssetResponseDto>}
     * @memberof AlbumResponseDto
     */
    'assets': Array<AssetResponseDto>;
}
/**
 * 
 * @export
 * @interface AllJobStatusResponseDto
 */
export interface AllJobStatusResponseDto {
    /**
     * 
     * @type {JobCounts}
     * @memberof AllJobStatusResponseDto
     */
    'thumbnailGenerationQueueCount': JobCounts;
    /**
     * 
     * @type {JobCounts}
     * @memberof AllJobStatusResponseDto
     */
    'metadataExtractionQueueCount': JobCounts;
    /**
     * 
     * @type {JobCounts}
     * @memberof AllJobStatusResponseDto
     */
    'videoConversionQueueCount': JobCounts;
    /**
     * 
     * @type {JobCounts}
     * @memberof AllJobStatusResponseDto
     */
    'machineLearningQueueCount': JobCounts;
    /**
     * 
     * @type {JobCounts}
     * @memberof AllJobStatusResponseDto
     */
    'storageMigrationQueueCount': JobCounts;
    /**
     * 
     * @type {boolean}
     * @memberof AllJobStatusResponseDto
     */
    'isThumbnailGenerationActive': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AllJobStatusResponseDto
     */
    'isMetadataExtractionActive': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AllJobStatusResponseDto
     */
    'isVideoConversionActive': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AllJobStatusResponseDto
     */
    'isMachineLearningActive': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AllJobStatusResponseDto
     */
    'isStorageMigrationActive': boolean;
}
/**
 * 
 * @export
 * @interface AssetCountByTimeBucket
 */
export interface AssetCountByTimeBucket {
    /**
     * 
     * @type {string}
     * @memberof AssetCountByTimeBucket
     */
    'timeBucket': string;
    /**
     * 
     * @type {number}
     * @memberof AssetCountByTimeBucket
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface AssetCountByTimeBucketResponseDto
 */
export interface AssetCountByTimeBucketResponseDto {
    /**
     * 
     * @type {number}
     * @memberof AssetCountByTimeBucketResponseDto
     */
    'totalCount': number;
    /**
     * 
     * @type {Array<AssetCountByTimeBucket>}
     * @memberof AssetCountByTimeBucketResponseDto
     */
    'buckets': Array<AssetCountByTimeBucket>;
}
/**
 * 
 * @export
 * @interface AssetCountByUserIdResponseDto
 */
export interface AssetCountByUserIdResponseDto {
    /**
     * 
     * @type {number}
     * @memberof AssetCountByUserIdResponseDto
     */
    'audio': number;
    /**
     * 
     * @type {number}
     * @memberof AssetCountByUserIdResponseDto
     */
    'photos': number;
    /**
     * 
     * @type {number}
     * @memberof AssetCountByUserIdResponseDto
     */
    'videos': number;
    /**
     * 
     * @type {number}
     * @memberof AssetCountByUserIdResponseDto
     */
    'other': number;
    /**
     * 
     * @type {number}
     * @memberof AssetCountByUserIdResponseDto
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface AssetFileUploadResponseDto
 */
export interface AssetFileUploadResponseDto {
    /**
     * 
     * @type {string}
     * @memberof AssetFileUploadResponseDto
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface AssetResponseDto
 */
export interface AssetResponseDto {
    /**
     * 
     * @type {AssetTypeEnum}
     * @memberof AssetResponseDto
     */
    'type': AssetTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof AssetResponseDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AssetResponseDto
     */
    'deviceAssetId': string;
    /**
     * 
     * @type {string}
     * @memberof AssetResponseDto
     */
    'ownerId': string;
    /**
     * 
     * @type {string}
     * @memberof AssetResponseDto
     */
    'deviceId': string;
    /**
     * 
     * @type {string}
     * @memberof AssetResponseDto
     */
    'originalPath': string;
    /**
     * 
     * @type {string}
     * @memberof AssetResponseDto
     */
    'resizePath': string | null;
    /**
     * 
     * @type {string}
     * @memberof AssetResponseDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof AssetResponseDto
     */
    'modifiedAt': string;
    /**
     * 
     * @type {boolean}
     * @memberof AssetResponseDto
     */
    'isFavorite': boolean;
    /**
     * 
     * @type {string}
     * @memberof AssetResponseDto
     */
    'mimeType': string | null;
    /**
     * 
     * @type {string}
     * @memberof AssetResponseDto
     */
    'duration': string;
    /**
     * 
     * @type {string}
     * @memberof AssetResponseDto
     */
    'webpPath': string | null;
    /**
     * 
     * @type {string}
     * @memberof AssetResponseDto
     */
    'encodedVideoPath'?: string | null;
    /**
     * 
     * @type {ExifResponseDto}
     * @memberof AssetResponseDto
     */
    'exifInfo'?: ExifResponseDto;
    /**
     * 
     * @type {SmartInfoResponseDto}
     * @memberof AssetResponseDto
     */
    'smartInfo'?: SmartInfoResponseDto;
    /**
     * 
     * @type {string}
     * @memberof AssetResponseDto
     */
    'livePhotoVideoId'?: string | null;
    /**
     * 
     * @type {Array<TagResponseDto>}
     * @memberof AssetResponseDto
     */
    'tags': Array<TagResponseDto>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const AssetTypeEnum = {
    Image: 'IMAGE',
    Video: 'VIDEO',
    Audio: 'AUDIO',
    Other: 'OTHER'
} as const;

export type AssetTypeEnum = typeof AssetTypeEnum[keyof typeof AssetTypeEnum];


/**
 * 
 * @export
 * @interface ChangePasswordDto
 */
export interface ChangePasswordDto {
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordDto
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordDto
     */
    'newPassword': string;
}
/**
 * 
 * @export
 * @interface CheckDuplicateAssetDto
 */
export interface CheckDuplicateAssetDto {
    /**
     * 
     * @type {string}
     * @memberof CheckDuplicateAssetDto
     */
    'deviceAssetId': string;
    /**
     * 
     * @type {string}
     * @memberof CheckDuplicateAssetDto
     */
    'deviceId': string;
}
/**
 * 
 * @export
 * @interface CheckDuplicateAssetResponseDto
 */
export interface CheckDuplicateAssetResponseDto {
    /**
     * 
     * @type {boolean}
     * @memberof CheckDuplicateAssetResponseDto
     */
    'isExist': boolean;
    /**
     * 
     * @type {string}
     * @memberof CheckDuplicateAssetResponseDto
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface CheckExistingAssetsDto
 */
export interface CheckExistingAssetsDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof CheckExistingAssetsDto
     */
    'deviceAssetIds': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CheckExistingAssetsDto
     */
    'deviceId': string;
}
/**
 * 
 * @export
 * @interface CheckExistingAssetsResponseDto
 */
export interface CheckExistingAssetsResponseDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof CheckExistingAssetsResponseDto
     */
    'existingIds': Array<string>;
}
/**
 * 
 * @export
 * @interface CreateAlbumDto
 */
export interface CreateAlbumDto {
    /**
     * 
     * @type {string}
     * @memberof CreateAlbumDto
     */
    'albumName': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateAlbumDto
     */
    'sharedWithUserIds'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateAlbumDto
     */
    'assetIds'?: Array<string>;
}
/**
 * 
 * @export
 * @interface CreateProfileImageResponseDto
 */
export interface CreateProfileImageResponseDto {
    /**
     * 
     * @type {string}
     * @memberof CreateProfileImageResponseDto
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateProfileImageResponseDto
     */
    'profileImagePath': string;
}
/**
 * 
 * @export
 * @interface CreateTagDto
 */
export interface CreateTagDto {
    /**
     * 
     * @type {TagTypeEnum}
     * @memberof CreateTagDto
     */
    'type': TagTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateTagDto
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface CreateUserDto
 */
export interface CreateUserDto {
    /**
     * 
     * @type {string}
     * @memberof CreateUserDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserDto
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserDto
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserDto
     */
    'lastName': string;
}
/**
 * 
 * @export
 * @interface CuratedLocationsResponseDto
 */
export interface CuratedLocationsResponseDto {
    /**
     * 
     * @type {string}
     * @memberof CuratedLocationsResponseDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CuratedLocationsResponseDto
     */
    'city': string;
    /**
     * 
     * @type {string}
     * @memberof CuratedLocationsResponseDto
     */
    'resizePath': string;
    /**
     * 
     * @type {string}
     * @memberof CuratedLocationsResponseDto
     */
    'deviceAssetId': string;
    /**
     * 
     * @type {string}
     * @memberof CuratedLocationsResponseDto
     */
    'deviceId': string;
}
/**
 * 
 * @export
 * @interface CuratedObjectsResponseDto
 */
export interface CuratedObjectsResponseDto {
    /**
     * 
     * @type {string}
     * @memberof CuratedObjectsResponseDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CuratedObjectsResponseDto
     */
    'object': string;
    /**
     * 
     * @type {string}
     * @memberof CuratedObjectsResponseDto
     */
    'resizePath': string;
    /**
     * 
     * @type {string}
     * @memberof CuratedObjectsResponseDto
     */
    'deviceAssetId': string;
    /**
     * 
     * @type {string}
     * @memberof CuratedObjectsResponseDto
     */
    'deviceId': string;
}
/**
 * 
 * @export
 * @interface DeleteAssetDto
 */
export interface DeleteAssetDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof DeleteAssetDto
     */
    'ids': Array<string>;
}
/**
 * 
 * @export
 * @interface DeleteAssetResponseDto
 */
export interface DeleteAssetResponseDto {
    /**
     * 
     * @type {DeleteAssetStatus}
     * @memberof DeleteAssetResponseDto
     */
    'status': DeleteAssetStatus;
    /**
     * 
     * @type {string}
     * @memberof DeleteAssetResponseDto
     */
    'id': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const DeleteAssetStatus = {
    Success: 'SUCCESS',
    Failed: 'FAILED'
} as const;

export type DeleteAssetStatus = typeof DeleteAssetStatus[keyof typeof DeleteAssetStatus];


/**
 * 
 * @export
 * @interface DeviceInfoResponseDto
 */
export interface DeviceInfoResponseDto {
    /**
     * 
     * @type {number}
     * @memberof DeviceInfoResponseDto
     */
    'id': number;
    /**
     * 
     * @type {DeviceTypeEnum}
     * @memberof DeviceInfoResponseDto
     */
    'deviceType': DeviceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof DeviceInfoResponseDto
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof DeviceInfoResponseDto
     */
    'deviceId': string;
    /**
     * 
     * @type {string}
     * @memberof DeviceInfoResponseDto
     */
    'createdAt': string;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceInfoResponseDto
     */
    'isAutoBackup': boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const DeviceTypeEnum = {
    Ios: 'IOS',
    Android: 'ANDROID',
    Web: 'WEB'
} as const;

export type DeviceTypeEnum = typeof DeviceTypeEnum[keyof typeof DeviceTypeEnum];


/**
 * 
 * @export
 * @interface ExifResponseDto
 */
export interface ExifResponseDto {
    /**
     * 
     * @type {number}
     * @memberof ExifResponseDto
     */
    'id'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ExifResponseDto
     */
    'fileSizeInByte'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ExifResponseDto
     */
    'make'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExifResponseDto
     */
    'model'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExifResponseDto
     */
    'imageName'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ExifResponseDto
     */
    'exifImageWidth'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ExifResponseDto
     */
    'exifImageHeight'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ExifResponseDto
     */
    'orientation'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExifResponseDto
     */
    'dateTimeOriginal'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExifResponseDto
     */
    'modifyDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExifResponseDto
     */
    'lensModel'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ExifResponseDto
     */
    'fNumber'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ExifResponseDto
     */
    'focalLength'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ExifResponseDto
     */
    'iso'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ExifResponseDto
     */
    'exposureTime'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ExifResponseDto
     */
    'latitude'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ExifResponseDto
     */
    'longitude'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ExifResponseDto
     */
    'city'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExifResponseDto
     */
    'state'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExifResponseDto
     */
    'country'?: string | null;
}
/**
 * 
 * @export
 * @interface GetAssetByTimeBucketDto
 */
export interface GetAssetByTimeBucketDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof GetAssetByTimeBucketDto
     */
    'timeBucket': Array<string>;
}
/**
 * 
 * @export
 * @interface GetAssetCountByTimeBucketDto
 */
export interface GetAssetCountByTimeBucketDto {
    /**
     * 
     * @type {TimeGroupEnum}
     * @memberof GetAssetCountByTimeBucketDto
     */
    'timeGroup': TimeGroupEnum;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const JobCommand = {
    Start: 'start',
    Stop: 'stop'
} as const;

export type JobCommand = typeof JobCommand[keyof typeof JobCommand];


/**
 * 
 * @export
 * @interface JobCommandDto
 */
export interface JobCommandDto {
    /**
     * 
     * @type {JobCommand}
     * @memberof JobCommandDto
     */
    'command': JobCommand;
}
/**
 * 
 * @export
 * @interface JobCounts
 */
export interface JobCounts {
    /**
     * 
     * @type {number}
     * @memberof JobCounts
     */
    'active': number;
    /**
     * 
     * @type {number}
     * @memberof JobCounts
     */
    'completed': number;
    /**
     * 
     * @type {number}
     * @memberof JobCounts
     */
    'failed': number;
    /**
     * 
     * @type {number}
     * @memberof JobCounts
     */
    'delayed': number;
    /**
     * 
     * @type {number}
     * @memberof JobCounts
     */
    'waiting': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const JobId = {
    ThumbnailGeneration: 'thumbnail-generation',
    MetadataExtraction: 'metadata-extraction',
    VideoConversion: 'video-conversion',
    MachineLearning: 'machine-learning',
    StorageTemplateMigration: 'storage-template-migration'
} as const;

export type JobId = typeof JobId[keyof typeof JobId];


/**
 * 
 * @export
 * @interface JobStatusResponseDto
 */
export interface JobStatusResponseDto {
    /**
     * 
     * @type {boolean}
     * @memberof JobStatusResponseDto
     */
    'isActive': boolean;
    /**
     * 
     * @type {object}
     * @memberof JobStatusResponseDto
     */
    'queueCount': object;
}
/**
 * 
 * @export
 * @interface LoginCredentialDto
 */
export interface LoginCredentialDto {
    /**
     * 
     * @type {string}
     * @memberof LoginCredentialDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof LoginCredentialDto
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface LoginResponseDto
 */
export interface LoginResponseDto {
    /**
     * 
     * @type {string}
     * @memberof LoginResponseDto
     */
    'accessToken': string;
    /**
     * 
     * @type {string}
     * @memberof LoginResponseDto
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof LoginResponseDto
     */
    'userEmail': string;
    /**
     * 
     * @type {string}
     * @memberof LoginResponseDto
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof LoginResponseDto
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof LoginResponseDto
     */
    'profileImagePath': string;
    /**
     * 
     * @type {boolean}
     * @memberof LoginResponseDto
     */
    'isAdmin': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LoginResponseDto
     */
    'shouldChangePassword': boolean;
}
/**
 * 
 * @export
 * @interface LogoutResponseDto
 */
export interface LogoutResponseDto {
    /**
     * 
     * @type {boolean}
     * @memberof LogoutResponseDto
     */
    'successful': boolean;
    /**
     * 
     * @type {string}
     * @memberof LogoutResponseDto
     */
    'redirectUri': string;
}
/**
 * 
 * @export
 * @interface OAuthCallbackDto
 */
export interface OAuthCallbackDto {
    /**
     * 
     * @type {string}
     * @memberof OAuthCallbackDto
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface OAuthConfigDto
 */
export interface OAuthConfigDto {
    /**
     * 
     * @type {string}
     * @memberof OAuthConfigDto
     */
    'redirectUri': string;
}
/**
 * 
 * @export
 * @interface OAuthConfigResponseDto
 */
export interface OAuthConfigResponseDto {
    /**
     * 
     * @type {boolean}
     * @memberof OAuthConfigResponseDto
     */
    'enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof OAuthConfigResponseDto
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuthConfigResponseDto
     */
    'buttonText'?: string;
}
/**
 * 
 * @export
 * @interface RemoveAssetsDto
 */
export interface RemoveAssetsDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof RemoveAssetsDto
     */
    'assetIds': Array<string>;
}
/**
 * 
 * @export
 * @interface SearchAssetDto
 */
export interface SearchAssetDto {
    /**
     * 
     * @type {string}
     * @memberof SearchAssetDto
     */
    'searchTerm': string;
}
/**
 * 
 * @export
 * @interface ServerInfoResponseDto
 */
export interface ServerInfoResponseDto {
    /**
     * 
     * @type {number}
     * @memberof ServerInfoResponseDto
     */
    'diskSizeRaw': number;
    /**
     * 
     * @type {number}
     * @memberof ServerInfoResponseDto
     */
    'diskUseRaw': number;
    /**
     * 
     * @type {number}
     * @memberof ServerInfoResponseDto
     */
    'diskAvailableRaw': number;
    /**
     * 
     * @type {number}
     * @memberof ServerInfoResponseDto
     */
    'diskUsagePercentage': number;
    /**
     * 
     * @type {string}
     * @memberof ServerInfoResponseDto
     */
    'diskSize': string;
    /**
     * 
     * @type {string}
     * @memberof ServerInfoResponseDto
     */
    'diskUse': string;
    /**
     * 
     * @type {string}
     * @memberof ServerInfoResponseDto
     */
    'diskAvailable': string;
}
/**
 * 
 * @export
 * @interface ServerPingResponse
 */
export interface ServerPingResponse {
    /**
     * 
     * @type {string}
     * @memberof ServerPingResponse
     */
    'res': string;
}
/**
 * 
 * @export
 * @interface ServerStatsResponseDto
 */
export interface ServerStatsResponseDto {
    /**
     * 
     * @type {number}
     * @memberof ServerStatsResponseDto
     */
    'photos': number;
    /**
     * 
     * @type {number}
     * @memberof ServerStatsResponseDto
     */
    'videos': number;
    /**
     * 
     * @type {number}
     * @memberof ServerStatsResponseDto
     */
    'objects': number;
    /**
     * 
     * @type {number}
     * @memberof ServerStatsResponseDto
     */
    'usageRaw': number;
    /**
     * 
     * @type {string}
     * @memberof ServerStatsResponseDto
     */
    'usage': string;
    /**
     * 
     * @type {Array<UsageByUserDto>}
     * @memberof ServerStatsResponseDto
     */
    'usageByUser': Array<UsageByUserDto>;
}
/**
 * 
 * @export
 * @interface ServerVersionReponseDto
 */
export interface ServerVersionReponseDto {
    /**
     * 
     * @type {number}
     * @memberof ServerVersionReponseDto
     */
    'major': number;
    /**
     * 
     * @type {number}
     * @memberof ServerVersionReponseDto
     */
    'minor': number;
    /**
     * 
     * @type {number}
     * @memberof ServerVersionReponseDto
     */
    'patch': number;
    /**
     * 
     * @type {number}
     * @memberof ServerVersionReponseDto
     */
    'build': number;
}
/**
 * 
 * @export
 * @interface SignUpDto
 */
export interface SignUpDto {
    /**
     * 
     * @type {string}
     * @memberof SignUpDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpDto
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpDto
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpDto
     */
    'lastName': string;
}
/**
 * 
 * @export
 * @interface SmartInfoResponseDto
 */
export interface SmartInfoResponseDto {
    /**
     * 
     * @type {string}
     * @memberof SmartInfoResponseDto
     */
    'id'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof SmartInfoResponseDto
     */
    'tags'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof SmartInfoResponseDto
     */
    'objects'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface SystemConfigDto
 */
export interface SystemConfigDto {
    /**
     * 
     * @type {SystemConfigFFmpegDto}
     * @memberof SystemConfigDto
     */
    'ffmpeg': SystemConfigFFmpegDto;
    /**
     * 
     * @type {SystemConfigOAuthDto}
     * @memberof SystemConfigDto
     */
    'oauth': SystemConfigOAuthDto;
    /**
     * 
     * @type {SystemConfigStorageTemplateDto}
     * @memberof SystemConfigDto
     */
    'storageTemplate': SystemConfigStorageTemplateDto;
}
/**
 * 
 * @export
 * @interface SystemConfigFFmpegDto
 */
export interface SystemConfigFFmpegDto {
    /**
     * 
     * @type {string}
     * @memberof SystemConfigFFmpegDto
     */
    'crf': string;
    /**
     * 
     * @type {string}
     * @memberof SystemConfigFFmpegDto
     */
    'preset': string;
    /**
     * 
     * @type {string}
     * @memberof SystemConfigFFmpegDto
     */
    'targetVideoCodec': string;
    /**
     * 
     * @type {string}
     * @memberof SystemConfigFFmpegDto
     */
    'targetAudioCodec': string;
    /**
     * 
     * @type {string}
     * @memberof SystemConfigFFmpegDto
     */
    'targetScaling': string;
}
/**
 * 
 * @export
 * @interface SystemConfigOAuthDto
 */
export interface SystemConfigOAuthDto {
    /**
     * 
     * @type {boolean}
     * @memberof SystemConfigOAuthDto
     */
    'enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof SystemConfigOAuthDto
     */
    'issuerUrl': string;
    /**
     * 
     * @type {string}
     * @memberof SystemConfigOAuthDto
     */
    'clientId': string;
    /**
     * 
     * @type {string}
     * @memberof SystemConfigOAuthDto
     */
    'clientSecret': string;
    /**
     * 
     * @type {string}
     * @memberof SystemConfigOAuthDto
     */
    'scope': string;
    /**
     * 
     * @type {string}
     * @memberof SystemConfigOAuthDto
     */
    'buttonText': string;
    /**
     * 
     * @type {boolean}
     * @memberof SystemConfigOAuthDto
     */
    'autoRegister': boolean;
}
/**
 * 
 * @export
 * @interface SystemConfigStorageTemplateDto
 */
export interface SystemConfigStorageTemplateDto {
    /**
     * 
     * @type {string}
     * @memberof SystemConfigStorageTemplateDto
     */
    'template': string;
}
/**
 * 
 * @export
 * @interface SystemConfigTemplateStorageOptionDto
 */
export interface SystemConfigTemplateStorageOptionDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof SystemConfigTemplateStorageOptionDto
     */
    'yearOptions': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SystemConfigTemplateStorageOptionDto
     */
    'monthOptions': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SystemConfigTemplateStorageOptionDto
     */
    'dayOptions': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SystemConfigTemplateStorageOptionDto
     */
    'hourOptions': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SystemConfigTemplateStorageOptionDto
     */
    'minuteOptions': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SystemConfigTemplateStorageOptionDto
     */
    'secondOptions': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SystemConfigTemplateStorageOptionDto
     */
    'presetOptions': Array<string>;
}
/**
 * 
 * @export
 * @interface TagResponseDto
 */
export interface TagResponseDto {
    /**
     * 
     * @type {string}
     * @memberof TagResponseDto
     */
    'id': string;
    /**
     * 
     * @type {TagTypeEnum}
     * @memberof TagResponseDto
     */
    'type': TagTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TagResponseDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TagResponseDto
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof TagResponseDto
     */
    'renameTagId'?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const TagTypeEnum = {
    Object: 'OBJECT',
    Face: 'FACE',
    Custom: 'CUSTOM'
} as const;

export type TagTypeEnum = typeof TagTypeEnum[keyof typeof TagTypeEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const ThumbnailFormat = {
    Jpeg: 'JPEG',
    Webp: 'WEBP'
} as const;

export type ThumbnailFormat = typeof ThumbnailFormat[keyof typeof ThumbnailFormat];


/**
 * 
 * @export
 * @enum {string}
 */

export const TimeGroupEnum = {
    Day: 'day',
    Month: 'month'
} as const;

export type TimeGroupEnum = typeof TimeGroupEnum[keyof typeof TimeGroupEnum];


/**
 * 
 * @export
 * @interface UpdateAlbumDto
 */
export interface UpdateAlbumDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateAlbumDto
     */
    'albumName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAlbumDto
     */
    'albumThumbnailAssetId'?: string;
}
/**
 * 
 * @export
 * @interface UpdateAssetDto
 */
export interface UpdateAssetDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateAssetDto
     */
    'tagIds'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateAssetDto
     */
    'isFavorite'?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateTagDto
 */
export interface UpdateTagDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateTagDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTagDto
     */
    'renameTagId'?: string;
}
/**
 * 
 * @export
 * @interface UpdateUserDto
 */
export interface UpdateUserDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'lastName'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateUserDto
     */
    'isAdmin'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateUserDto
     */
    'shouldChangePassword'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'profileImagePath'?: string;
}
/**
 * 
 * @export
 * @interface UpsertDeviceInfoDto
 */
export interface UpsertDeviceInfoDto {
    /**
     * 
     * @type {DeviceTypeEnum}
     * @memberof UpsertDeviceInfoDto
     */
    'deviceType': DeviceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof UpsertDeviceInfoDto
     */
    'deviceId': string;
    /**
     * 
     * @type {boolean}
     * @memberof UpsertDeviceInfoDto
     */
    'isAutoBackup'?: boolean;
}
/**
 * 
 * @export
 * @interface UsageByUserDto
 */
export interface UsageByUserDto {
    /**
     * 
     * @type {string}
     * @memberof UsageByUserDto
     */
    'userId': string;
    /**
     * 
     * @type {number}
     * @memberof UsageByUserDto
     */
    'videos': number;
    /**
     * 
     * @type {number}
     * @memberof UsageByUserDto
     */
    'photos': number;
    /**
     * 
     * @type {number}
     * @memberof UsageByUserDto
     */
    'usageRaw': number;
    /**
     * 
     * @type {string}
     * @memberof UsageByUserDto
     */
    'usage': string;
}
/**
 * 
 * @export
 * @interface UserCountResponseDto
 */
export interface UserCountResponseDto {
    /**
     * 
     * @type {number}
     * @memberof UserCountResponseDto
     */
    'userCount': number;
}
/**
 * 
 * @export
 * @interface UserResponseDto
 */
export interface UserResponseDto {
    /**
     * 
     * @type {string}
     * @memberof UserResponseDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserResponseDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserResponseDto
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof UserResponseDto
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof UserResponseDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserResponseDto
     */
    'profileImagePath': string;
    /**
     * 
     * @type {boolean}
     * @memberof UserResponseDto
     */
    'shouldChangePassword': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserResponseDto
     */
    'isAdmin': boolean;
    /**
     * 
     * @type {string}
     * @memberof UserResponseDto
     */
    'deletedAt'?: string;
}
/**
 * 
 * @export
 * @interface ValidateAccessTokenResponseDto
 */
export interface ValidateAccessTokenResponseDto {
    /**
     * 
     * @type {boolean}
     * @memberof ValidateAccessTokenResponseDto
     */
    'authStatus': boolean;
}

/**
 * AlbumApi - axios parameter creator
 * @export
 */
export const AlbumApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} albumId 
         * @param {AddAssetsDto} addAssetsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAssetsToAlbum: async (albumId: string, addAssetsDto: AddAssetsDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'albumId' is not null or undefined
            assertParamExists('addAssetsToAlbum', 'albumId', albumId)
            // verify required parameter 'addAssetsDto' is not null or undefined
            assertParamExists('addAssetsToAlbum', 'addAssetsDto', addAssetsDto)
            const localVarPath = `/album/{albumId}/assets`
                .replace(`{${"albumId"}}`, encodeURIComponent(String(albumId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addAssetsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} albumId 
         * @param {AddUsersDto} addUsersDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUsersToAlbum: async (albumId: string, addUsersDto: AddUsersDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'albumId' is not null or undefined
            assertParamExists('addUsersToAlbum', 'albumId', albumId)
            // verify required parameter 'addUsersDto' is not null or undefined
            assertParamExists('addUsersToAlbum', 'addUsersDto', addUsersDto)
            const localVarPath = `/album/{albumId}/users`
                .replace(`{${"albumId"}}`, encodeURIComponent(String(albumId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addUsersDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateAlbumDto} createAlbumDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlbum: async (createAlbumDto: CreateAlbumDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createAlbumDto' is not null or undefined
            assertParamExists('createAlbum', 'createAlbumDto', createAlbumDto)
            const localVarPath = `/album`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAlbumDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} albumId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlbum: async (albumId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'albumId' is not null or undefined
            assertParamExists('deleteAlbum', 'albumId', albumId)
            const localVarPath = `/album/{albumId}`
                .replace(`{${"albumId"}}`, encodeURIComponent(String(albumId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} albumId 
         * @param {number} [skip] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadArchive: async (albumId: string, skip?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'albumId' is not null or undefined
            assertParamExists('downloadArchive', 'albumId', albumId)
            const localVarPath = `/album/{albumId}/download`
                .replace(`{${"albumId"}}`, encodeURIComponent(String(albumId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlbumCountByUserId: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/album/count-by-user-id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} albumId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlbumInfo: async (albumId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'albumId' is not null or undefined
            assertParamExists('getAlbumInfo', 'albumId', albumId)
            const localVarPath = `/album/{albumId}`
                .replace(`{${"albumId"}}`, encodeURIComponent(String(albumId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} [shared] 
         * @param {string} [assetId] Only returns albums that contain the asset Ignores the shared parameter undefined: get all albums
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAlbums: async (shared?: boolean, assetId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/album`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (shared !== undefined) {
                localVarQueryParameter['shared'] = shared;
            }

            if (assetId !== undefined) {
                localVarQueryParameter['assetId'] = assetId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} albumId 
         * @param {RemoveAssetsDto} removeAssetsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAssetFromAlbum: async (albumId: string, removeAssetsDto: RemoveAssetsDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'albumId' is not null or undefined
            assertParamExists('removeAssetFromAlbum', 'albumId', albumId)
            // verify required parameter 'removeAssetsDto' is not null or undefined
            assertParamExists('removeAssetFromAlbum', 'removeAssetsDto', removeAssetsDto)
            const localVarPath = `/album/{albumId}/assets`
                .replace(`{${"albumId"}}`, encodeURIComponent(String(albumId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(removeAssetsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} albumId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserFromAlbum: async (albumId: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'albumId' is not null or undefined
            assertParamExists('removeUserFromAlbum', 'albumId', albumId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('removeUserFromAlbum', 'userId', userId)
            const localVarPath = `/album/{albumId}/user/{userId}`
                .replace(`{${"albumId"}}`, encodeURIComponent(String(albumId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} albumId 
         * @param {UpdateAlbumDto} updateAlbumDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAlbumInfo: async (albumId: string, updateAlbumDto: UpdateAlbumDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'albumId' is not null or undefined
            assertParamExists('updateAlbumInfo', 'albumId', albumId)
            // verify required parameter 'updateAlbumDto' is not null or undefined
            assertParamExists('updateAlbumInfo', 'updateAlbumDto', updateAlbumDto)
            const localVarPath = `/album/{albumId}`
                .replace(`{${"albumId"}}`, encodeURIComponent(String(albumId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAlbumDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AlbumApi - functional programming interface
 * @export
 */
export const AlbumApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AlbumApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} albumId 
         * @param {AddAssetsDto} addAssetsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addAssetsToAlbum(albumId: string, addAssetsDto: AddAssetsDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddAssetsResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addAssetsToAlbum(albumId, addAssetsDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} albumId 
         * @param {AddUsersDto} addUsersDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUsersToAlbum(albumId: string, addUsersDto: AddUsersDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlbumResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addUsersToAlbum(albumId, addUsersDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CreateAlbumDto} createAlbumDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAlbum(createAlbumDto: CreateAlbumDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlbumResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAlbum(createAlbumDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} albumId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAlbum(albumId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAlbum(albumId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} albumId 
         * @param {number} [skip] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadArchive(albumId: string, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadArchive(albumId, skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAlbumCountByUserId(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlbumCountResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAlbumCountByUserId(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} albumId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAlbumInfo(albumId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlbumResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAlbumInfo(albumId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {boolean} [shared] 
         * @param {string} [assetId] Only returns albums that contain the asset Ignores the shared parameter undefined: get all albums
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllAlbums(shared?: boolean, assetId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AlbumResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllAlbums(shared, assetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} albumId 
         * @param {RemoveAssetsDto} removeAssetsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeAssetFromAlbum(albumId: string, removeAssetsDto: RemoveAssetsDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlbumResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeAssetFromAlbum(albumId, removeAssetsDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} albumId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeUserFromAlbum(albumId: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeUserFromAlbum(albumId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} albumId 
         * @param {UpdateAlbumDto} updateAlbumDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAlbumInfo(albumId: string, updateAlbumDto: UpdateAlbumDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlbumResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAlbumInfo(albumId, updateAlbumDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AlbumApi - factory interface
 * @export
 */
export const AlbumApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AlbumApiFp(configuration)
    return {
        /**
         * 
         * @param {string} albumId 
         * @param {AddAssetsDto} addAssetsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAssetsToAlbum(albumId: string, addAssetsDto: AddAssetsDto, options?: any): AxiosPromise<AddAssetsResponseDto> {
            return localVarFp.addAssetsToAlbum(albumId, addAssetsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} albumId 
         * @param {AddUsersDto} addUsersDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUsersToAlbum(albumId: string, addUsersDto: AddUsersDto, options?: any): AxiosPromise<AlbumResponseDto> {
            return localVarFp.addUsersToAlbum(albumId, addUsersDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateAlbumDto} createAlbumDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlbum(createAlbumDto: CreateAlbumDto, options?: any): AxiosPromise<AlbumResponseDto> {
            return localVarFp.createAlbum(createAlbumDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} albumId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlbum(albumId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAlbum(albumId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} albumId 
         * @param {number} [skip] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadArchive(albumId: string, skip?: number, options?: any): AxiosPromise<object> {
            return localVarFp.downloadArchive(albumId, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlbumCountByUserId(options?: any): AxiosPromise<AlbumCountResponseDto> {
            return localVarFp.getAlbumCountByUserId(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} albumId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlbumInfo(albumId: string, options?: any): AxiosPromise<AlbumResponseDto> {
            return localVarFp.getAlbumInfo(albumId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} [shared] 
         * @param {string} [assetId] Only returns albums that contain the asset Ignores the shared parameter undefined: get all albums
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAlbums(shared?: boolean, assetId?: string, options?: any): AxiosPromise<Array<AlbumResponseDto>> {
            return localVarFp.getAllAlbums(shared, assetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} albumId 
         * @param {RemoveAssetsDto} removeAssetsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAssetFromAlbum(albumId: string, removeAssetsDto: RemoveAssetsDto, options?: any): AxiosPromise<AlbumResponseDto> {
            return localVarFp.removeAssetFromAlbum(albumId, removeAssetsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} albumId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserFromAlbum(albumId: string, userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeUserFromAlbum(albumId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} albumId 
         * @param {UpdateAlbumDto} updateAlbumDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAlbumInfo(albumId: string, updateAlbumDto: UpdateAlbumDto, options?: any): AxiosPromise<AlbumResponseDto> {
            return localVarFp.updateAlbumInfo(albumId, updateAlbumDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AlbumApi - object-oriented interface
 * @export
 * @class AlbumApi
 * @extends {BaseAPI}
 */
export class AlbumApi extends BaseAPI {
    /**
     * 
     * @param {string} albumId 
     * @param {AddAssetsDto} addAssetsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    public addAssetsToAlbum(albumId: string, addAssetsDto: AddAssetsDto, options?: AxiosRequestConfig) {
        return AlbumApiFp(this.configuration).addAssetsToAlbum(albumId, addAssetsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} albumId 
     * @param {AddUsersDto} addUsersDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    public addUsersToAlbum(albumId: string, addUsersDto: AddUsersDto, options?: AxiosRequestConfig) {
        return AlbumApiFp(this.configuration).addUsersToAlbum(albumId, addUsersDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateAlbumDto} createAlbumDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    public createAlbum(createAlbumDto: CreateAlbumDto, options?: AxiosRequestConfig) {
        return AlbumApiFp(this.configuration).createAlbum(createAlbumDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} albumId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    public deleteAlbum(albumId: string, options?: AxiosRequestConfig) {
        return AlbumApiFp(this.configuration).deleteAlbum(albumId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} albumId 
     * @param {number} [skip] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    public downloadArchive(albumId: string, skip?: number, options?: AxiosRequestConfig) {
        return AlbumApiFp(this.configuration).downloadArchive(albumId, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    public getAlbumCountByUserId(options?: AxiosRequestConfig) {
        return AlbumApiFp(this.configuration).getAlbumCountByUserId(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} albumId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    public getAlbumInfo(albumId: string, options?: AxiosRequestConfig) {
        return AlbumApiFp(this.configuration).getAlbumInfo(albumId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {boolean} [shared] 
     * @param {string} [assetId] Only returns albums that contain the asset Ignores the shared parameter undefined: get all albums
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    public getAllAlbums(shared?: boolean, assetId?: string, options?: AxiosRequestConfig) {
        return AlbumApiFp(this.configuration).getAllAlbums(shared, assetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} albumId 
     * @param {RemoveAssetsDto} removeAssetsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    public removeAssetFromAlbum(albumId: string, removeAssetsDto: RemoveAssetsDto, options?: AxiosRequestConfig) {
        return AlbumApiFp(this.configuration).removeAssetFromAlbum(albumId, removeAssetsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} albumId 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    public removeUserFromAlbum(albumId: string, userId: string, options?: AxiosRequestConfig) {
        return AlbumApiFp(this.configuration).removeUserFromAlbum(albumId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} albumId 
     * @param {UpdateAlbumDto} updateAlbumDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    public updateAlbumInfo(albumId: string, updateAlbumDto: UpdateAlbumDto, options?: AxiosRequestConfig) {
        return AlbumApiFp(this.configuration).updateAlbumInfo(albumId, updateAlbumDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AssetApi - axios parameter creator
 * @export
 */
export const AssetApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Check duplicated asset before uploading - for Web upload used
         * @param {CheckDuplicateAssetDto} checkDuplicateAssetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkDuplicateAsset: async (checkDuplicateAssetDto: CheckDuplicateAssetDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkDuplicateAssetDto' is not null or undefined
            assertParamExists('checkDuplicateAsset', 'checkDuplicateAssetDto', checkDuplicateAssetDto)
            const localVarPath = `/asset/check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkDuplicateAssetDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Checks if multiple assets exist on the server and returns all existing - used by background backup
         * @param {CheckExistingAssetsDto} checkExistingAssetsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkExistingAssets: async (checkExistingAssetsDto: CheckExistingAssetsDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkExistingAssetsDto' is not null or undefined
            assertParamExists('checkExistingAssets', 'checkExistingAssetsDto', checkExistingAssetsDto)
            const localVarPath = `/asset/exist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkExistingAssetsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DeleteAssetDto} deleteAssetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAsset: async (deleteAssetDto: DeleteAssetDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteAssetDto' is not null or undefined
            assertParamExists('deleteAsset', 'deleteAssetDto', deleteAssetDto)
            const localVarPath = `/asset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteAssetDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} assetId 
         * @param {boolean} [isThumb] 
         * @param {boolean} [isWeb] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile: async (assetId: string, isThumb?: boolean, isWeb?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('downloadFile', 'assetId', assetId)
            const localVarPath = `/asset/download/{assetId}`
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (isThumb !== undefined) {
                localVarQueryParameter['isThumb'] = isThumb;
            }

            if (isWeb !== undefined) {
                localVarQueryParameter['isWeb'] = isWeb;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [skip] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadLibrary: async (skip?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/asset/download-library`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all AssetEntity belong to the user
         * @param {string} [ifNoneMatch] ETag of data already cached on the client
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAssets: async (ifNoneMatch?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/asset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['if-none-match'] = String(ifNoneMatch);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single asset\'s information
         * @param {string} assetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetById: async (assetId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('getAssetById', 'assetId', assetId)
            const localVarPath = `/asset/assetById/{assetId}`
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GetAssetByTimeBucketDto} getAssetByTimeBucketDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetByTimeBucket: async (getAssetByTimeBucketDto: GetAssetByTimeBucketDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getAssetByTimeBucketDto' is not null or undefined
            assertParamExists('getAssetByTimeBucket', 'getAssetByTimeBucketDto', getAssetByTimeBucketDto)
            const localVarPath = `/asset/time-bucket`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getAssetByTimeBucketDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GetAssetCountByTimeBucketDto} getAssetCountByTimeBucketDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetCountByTimeBucket: async (getAssetCountByTimeBucketDto: GetAssetCountByTimeBucketDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getAssetCountByTimeBucketDto' is not null or undefined
            assertParamExists('getAssetCountByTimeBucket', 'getAssetCountByTimeBucketDto', getAssetCountByTimeBucketDto)
            const localVarPath = `/asset/count-by-time-bucket`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getAssetCountByTimeBucketDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetCountByUserId: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/asset/count-by-user-id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetSearchTerms: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/asset/search-terms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} assetId 
         * @param {ThumbnailFormat} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetThumbnail: async (assetId: string, format?: ThumbnailFormat, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('getAssetThumbnail', 'assetId', assetId)
            const localVarPath = `/asset/thumbnail/{assetId}`
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCuratedLocations: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/asset/curated-locations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCuratedObjects: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/asset/curated-objects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all asset of a device that are in the database, ID only.
         * @param {string} deviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAssetsByDeviceId: async (deviceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('getUserAssetsByDeviceId', 'deviceId', deviceId)
            const localVarPath = `/asset/{deviceId}`
                .replace(`{${"deviceId"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SearchAssetDto} searchAssetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAsset: async (searchAssetDto: SearchAssetDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchAssetDto' is not null or undefined
            assertParamExists('searchAsset', 'searchAssetDto', searchAssetDto)
            const localVarPath = `/asset/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchAssetDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} assetId 
         * @param {boolean} [isThumb] 
         * @param {boolean} [isWeb] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serveFile: async (assetId: string, isThumb?: boolean, isWeb?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('serveFile', 'assetId', assetId)
            const localVarPath = `/asset/file/{assetId}`
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (isThumb !== undefined) {
                localVarQueryParameter['isThumb'] = isThumb;
            }

            if (isWeb !== undefined) {
                localVarQueryParameter['isWeb'] = isWeb;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an asset
         * @param {string} assetId 
         * @param {UpdateAssetDto} updateAssetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAsset: async (assetId: string, updateAssetDto: UpdateAssetDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('updateAsset', 'assetId', assetId)
            // verify required parameter 'updateAssetDto' is not null or undefined
            assertParamExists('updateAsset', 'updateAssetDto', updateAssetDto)
            const localVarPath = `/asset/{assetId}`
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAssetDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {any} assetData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile: async (assetData: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetData' is not null or undefined
            assertParamExists('uploadFile', 'assetData', assetData)
            const localVarPath = `/asset/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (assetData !== undefined) { 
                localVarFormParams.append('assetData', assetData as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AssetApi - functional programming interface
 * @export
 */
export const AssetApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AssetApiAxiosParamCreator(configuration)
    return {
        /**
         * Check duplicated asset before uploading - for Web upload used
         * @param {CheckDuplicateAssetDto} checkDuplicateAssetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkDuplicateAsset(checkDuplicateAssetDto: CheckDuplicateAssetDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckDuplicateAssetResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkDuplicateAsset(checkDuplicateAssetDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Checks if multiple assets exist on the server and returns all existing - used by background backup
         * @param {CheckExistingAssetsDto} checkExistingAssetsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkExistingAssets(checkExistingAssetsDto: CheckExistingAssetsDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckExistingAssetsResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkExistingAssets(checkExistingAssetsDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {DeleteAssetDto} deleteAssetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAsset(deleteAssetDto: DeleteAssetDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeleteAssetResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAsset(deleteAssetDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} assetId 
         * @param {boolean} [isThumb] 
         * @param {boolean} [isWeb] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadFile(assetId: string, isThumb?: boolean, isWeb?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadFile(assetId, isThumb, isWeb, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [skip] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadLibrary(skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadLibrary(skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all AssetEntity belong to the user
         * @param {string} [ifNoneMatch] ETag of data already cached on the client
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllAssets(ifNoneMatch?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AssetResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllAssets(ifNoneMatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single asset\'s information
         * @param {string} assetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssetById(assetId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssetById(assetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {GetAssetByTimeBucketDto} getAssetByTimeBucketDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssetByTimeBucket(getAssetByTimeBucketDto: GetAssetByTimeBucketDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AssetResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssetByTimeBucket(getAssetByTimeBucketDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {GetAssetCountByTimeBucketDto} getAssetCountByTimeBucketDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssetCountByTimeBucket(getAssetCountByTimeBucketDto: GetAssetCountByTimeBucketDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetCountByTimeBucketResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssetCountByTimeBucket(getAssetCountByTimeBucketDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssetCountByUserId(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetCountByUserIdResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssetCountByUserId(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssetSearchTerms(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssetSearchTerms(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} assetId 
         * @param {ThumbnailFormat} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssetThumbnail(assetId: string, format?: ThumbnailFormat, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssetThumbnail(assetId, format, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCuratedLocations(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CuratedLocationsResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCuratedLocations(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCuratedObjects(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CuratedObjectsResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCuratedObjects(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all asset of a device that are in the database, ID only.
         * @param {string} deviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserAssetsByDeviceId(deviceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserAssetsByDeviceId(deviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SearchAssetDto} searchAssetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchAsset(searchAssetDto: SearchAssetDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AssetResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchAsset(searchAssetDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} assetId 
         * @param {boolean} [isThumb] 
         * @param {boolean} [isWeb] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serveFile(assetId: string, isThumb?: boolean, isWeb?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serveFile(assetId, isThumb, isWeb, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an asset
         * @param {string} assetId 
         * @param {UpdateAssetDto} updateAssetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAsset(assetId: string, updateAssetDto: UpdateAssetDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAsset(assetId, updateAssetDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {any} assetData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFile(assetData: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetFileUploadResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFile(assetData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AssetApi - factory interface
 * @export
 */
export const AssetApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AssetApiFp(configuration)
    return {
        /**
         * Check duplicated asset before uploading - for Web upload used
         * @param {CheckDuplicateAssetDto} checkDuplicateAssetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkDuplicateAsset(checkDuplicateAssetDto: CheckDuplicateAssetDto, options?: any): AxiosPromise<CheckDuplicateAssetResponseDto> {
            return localVarFp.checkDuplicateAsset(checkDuplicateAssetDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Checks if multiple assets exist on the server and returns all existing - used by background backup
         * @param {CheckExistingAssetsDto} checkExistingAssetsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkExistingAssets(checkExistingAssetsDto: CheckExistingAssetsDto, options?: any): AxiosPromise<CheckExistingAssetsResponseDto> {
            return localVarFp.checkExistingAssets(checkExistingAssetsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DeleteAssetDto} deleteAssetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAsset(deleteAssetDto: DeleteAssetDto, options?: any): AxiosPromise<Array<DeleteAssetResponseDto>> {
            return localVarFp.deleteAsset(deleteAssetDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} assetId 
         * @param {boolean} [isThumb] 
         * @param {boolean} [isWeb] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile(assetId: string, isThumb?: boolean, isWeb?: boolean, options?: any): AxiosPromise<object> {
            return localVarFp.downloadFile(assetId, isThumb, isWeb, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [skip] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadLibrary(skip?: number, options?: any): AxiosPromise<object> {
            return localVarFp.downloadLibrary(skip, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all AssetEntity belong to the user
         * @param {string} [ifNoneMatch] ETag of data already cached on the client
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAssets(ifNoneMatch?: string, options?: any): AxiosPromise<Array<AssetResponseDto>> {
            return localVarFp.getAllAssets(ifNoneMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single asset\'s information
         * @param {string} assetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetById(assetId: string, options?: any): AxiosPromise<AssetResponseDto> {
            return localVarFp.getAssetById(assetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GetAssetByTimeBucketDto} getAssetByTimeBucketDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetByTimeBucket(getAssetByTimeBucketDto: GetAssetByTimeBucketDto, options?: any): AxiosPromise<Array<AssetResponseDto>> {
            return localVarFp.getAssetByTimeBucket(getAssetByTimeBucketDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GetAssetCountByTimeBucketDto} getAssetCountByTimeBucketDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetCountByTimeBucket(getAssetCountByTimeBucketDto: GetAssetCountByTimeBucketDto, options?: any): AxiosPromise<AssetCountByTimeBucketResponseDto> {
            return localVarFp.getAssetCountByTimeBucket(getAssetCountByTimeBucketDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetCountByUserId(options?: any): AxiosPromise<AssetCountByUserIdResponseDto> {
            return localVarFp.getAssetCountByUserId(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetSearchTerms(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getAssetSearchTerms(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} assetId 
         * @param {ThumbnailFormat} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetThumbnail(assetId: string, format?: ThumbnailFormat, options?: any): AxiosPromise<object> {
            return localVarFp.getAssetThumbnail(assetId, format, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCuratedLocations(options?: any): AxiosPromise<Array<CuratedLocationsResponseDto>> {
            return localVarFp.getCuratedLocations(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCuratedObjects(options?: any): AxiosPromise<Array<CuratedObjectsResponseDto>> {
            return localVarFp.getCuratedObjects(options).then((request) => request(axios, basePath));
        },
        /**
         * Get all asset of a device that are in the database, ID only.
         * @param {string} deviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAssetsByDeviceId(deviceId: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getUserAssetsByDeviceId(deviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SearchAssetDto} searchAssetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAsset(searchAssetDto: SearchAssetDto, options?: any): AxiosPromise<Array<AssetResponseDto>> {
            return localVarFp.searchAsset(searchAssetDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} assetId 
         * @param {boolean} [isThumb] 
         * @param {boolean} [isWeb] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serveFile(assetId: string, isThumb?: boolean, isWeb?: boolean, options?: any): AxiosPromise<object> {
            return localVarFp.serveFile(assetId, isThumb, isWeb, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an asset
         * @param {string} assetId 
         * @param {UpdateAssetDto} updateAssetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAsset(assetId: string, updateAssetDto: UpdateAssetDto, options?: any): AxiosPromise<AssetResponseDto> {
            return localVarFp.updateAsset(assetId, updateAssetDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {any} assetData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile(assetData: any, options?: any): AxiosPromise<AssetFileUploadResponseDto> {
            return localVarFp.uploadFile(assetData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AssetApi - object-oriented interface
 * @export
 * @class AssetApi
 * @extends {BaseAPI}
 */
export class AssetApi extends BaseAPI {
    /**
     * Check duplicated asset before uploading - for Web upload used
     * @param {CheckDuplicateAssetDto} checkDuplicateAssetDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public checkDuplicateAsset(checkDuplicateAssetDto: CheckDuplicateAssetDto, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).checkDuplicateAsset(checkDuplicateAssetDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Checks if multiple assets exist on the server and returns all existing - used by background backup
     * @param {CheckExistingAssetsDto} checkExistingAssetsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public checkExistingAssets(checkExistingAssetsDto: CheckExistingAssetsDto, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).checkExistingAssets(checkExistingAssetsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DeleteAssetDto} deleteAssetDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public deleteAsset(deleteAssetDto: DeleteAssetDto, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).deleteAsset(deleteAssetDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} assetId 
     * @param {boolean} [isThumb] 
     * @param {boolean} [isWeb] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public downloadFile(assetId: string, isThumb?: boolean, isWeb?: boolean, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).downloadFile(assetId, isThumb, isWeb, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [skip] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public downloadLibrary(skip?: number, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).downloadLibrary(skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all AssetEntity belong to the user
     * @param {string} [ifNoneMatch] ETag of data already cached on the client
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getAllAssets(ifNoneMatch?: string, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getAllAssets(ifNoneMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single asset\'s information
     * @param {string} assetId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getAssetById(assetId: string, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getAssetById(assetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GetAssetByTimeBucketDto} getAssetByTimeBucketDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getAssetByTimeBucket(getAssetByTimeBucketDto: GetAssetByTimeBucketDto, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getAssetByTimeBucket(getAssetByTimeBucketDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GetAssetCountByTimeBucketDto} getAssetCountByTimeBucketDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getAssetCountByTimeBucket(getAssetCountByTimeBucketDto: GetAssetCountByTimeBucketDto, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getAssetCountByTimeBucket(getAssetCountByTimeBucketDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getAssetCountByUserId(options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getAssetCountByUserId(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getAssetSearchTerms(options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getAssetSearchTerms(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} assetId 
     * @param {ThumbnailFormat} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getAssetThumbnail(assetId: string, format?: ThumbnailFormat, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getAssetThumbnail(assetId, format, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getCuratedLocations(options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getCuratedLocations(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getCuratedObjects(options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getCuratedObjects(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all asset of a device that are in the database, ID only.
     * @param {string} deviceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getUserAssetsByDeviceId(deviceId: string, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getUserAssetsByDeviceId(deviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SearchAssetDto} searchAssetDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public searchAsset(searchAssetDto: SearchAssetDto, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).searchAsset(searchAssetDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} assetId 
     * @param {boolean} [isThumb] 
     * @param {boolean} [isWeb] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public serveFile(assetId: string, isThumb?: boolean, isWeb?: boolean, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).serveFile(assetId, isThumb, isWeb, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an asset
     * @param {string} assetId 
     * @param {UpdateAssetDto} updateAssetDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public updateAsset(assetId: string, updateAssetDto: UpdateAssetDto, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).updateAsset(assetId, updateAssetDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {any} assetData 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public uploadFile(assetData: any, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).uploadFile(assetData, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {SignUpDto} signUpDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminSignUp: async (signUpDto: SignUpDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signUpDto' is not null or undefined
            assertParamExists('adminSignUp', 'signUpDto', signUpDto)
            const localVarPath = `/auth/admin-sign-up`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signUpDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ChangePasswordDto} changePasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword: async (changePasswordDto: ChangePasswordDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'changePasswordDto' is not null or undefined
            assertParamExists('changePassword', 'changePasswordDto', changePasswordDto)
            const localVarPath = `/auth/change-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changePasswordDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {LoginCredentialDto} loginCredentialDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginCredentialDto: LoginCredentialDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginCredentialDto' is not null or undefined
            assertParamExists('login', 'loginCredentialDto', loginCredentialDto)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginCredentialDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateAccessToken: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/validateToken`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {SignUpDto} signUpDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminSignUp(signUpDto: SignUpDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminSignupResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminSignUp(signUpDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ChangePasswordDto} changePasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changePassword(changePasswordDto: ChangePasswordDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changePassword(changePasswordDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {LoginCredentialDto} loginCredentialDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginCredentialDto: LoginCredentialDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginCredentialDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogoutResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateAccessToken(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidateAccessTokenResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateAccessToken(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * 
         * @param {SignUpDto} signUpDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminSignUp(signUpDto: SignUpDto, options?: any): AxiosPromise<AdminSignupResponseDto> {
            return localVarFp.adminSignUp(signUpDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ChangePasswordDto} changePasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(changePasswordDto: ChangePasswordDto, options?: any): AxiosPromise<UserResponseDto> {
            return localVarFp.changePassword(changePasswordDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {LoginCredentialDto} loginCredentialDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginCredentialDto: LoginCredentialDto, options?: any): AxiosPromise<LoginResponseDto> {
            return localVarFp.login(loginCredentialDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: any): AxiosPromise<LogoutResponseDto> {
            return localVarFp.logout(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateAccessToken(options?: any): AxiosPromise<ValidateAccessTokenResponseDto> {
            return localVarFp.validateAccessToken(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * 
     * @param {SignUpDto} signUpDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public adminSignUp(signUpDto: SignUpDto, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).adminSignUp(signUpDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ChangePasswordDto} changePasswordDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public changePassword(changePasswordDto: ChangePasswordDto, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).changePassword(changePasswordDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LoginCredentialDto} loginCredentialDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public login(loginCredentialDto: LoginCredentialDto, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).login(loginCredentialDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public logout(options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).logout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public validateAccessToken(options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).validateAccessToken(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DeviceInfoApi - axios parameter creator
 * @export
 */
export const DeviceInfoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * @deprecated
         * @param {UpsertDeviceInfoDto} upsertDeviceInfoDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeviceInfo: async (upsertDeviceInfoDto: UpsertDeviceInfoDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'upsertDeviceInfoDto' is not null or undefined
            assertParamExists('createDeviceInfo', 'upsertDeviceInfoDto', upsertDeviceInfoDto)
            const localVarPath = `/device-info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(upsertDeviceInfoDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * @deprecated
         * @param {UpsertDeviceInfoDto} upsertDeviceInfoDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceInfo: async (upsertDeviceInfoDto: UpsertDeviceInfoDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'upsertDeviceInfoDto' is not null or undefined
            assertParamExists('updateDeviceInfo', 'upsertDeviceInfoDto', upsertDeviceInfoDto)
            const localVarPath = `/device-info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(upsertDeviceInfoDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpsertDeviceInfoDto} upsertDeviceInfoDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertDeviceInfo: async (upsertDeviceInfoDto: UpsertDeviceInfoDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'upsertDeviceInfoDto' is not null or undefined
            assertParamExists('upsertDeviceInfo', 'upsertDeviceInfoDto', upsertDeviceInfoDto)
            const localVarPath = `/device-info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(upsertDeviceInfoDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeviceInfoApi - functional programming interface
 * @export
 */
export const DeviceInfoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeviceInfoApiAxiosParamCreator(configuration)
    return {
        /**
         * @deprecated
         * @param {UpsertDeviceInfoDto} upsertDeviceInfoDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDeviceInfo(upsertDeviceInfoDto: UpsertDeviceInfoDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceInfoResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDeviceInfo(upsertDeviceInfoDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * @deprecated
         * @param {UpsertDeviceInfoDto} upsertDeviceInfoDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDeviceInfo(upsertDeviceInfoDto: UpsertDeviceInfoDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceInfoResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDeviceInfo(upsertDeviceInfoDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {UpsertDeviceInfoDto} upsertDeviceInfoDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upsertDeviceInfo(upsertDeviceInfoDto: UpsertDeviceInfoDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceInfoResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.upsertDeviceInfo(upsertDeviceInfoDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DeviceInfoApi - factory interface
 * @export
 */
export const DeviceInfoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeviceInfoApiFp(configuration)
    return {
        /**
         * @deprecated
         * @param {UpsertDeviceInfoDto} upsertDeviceInfoDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeviceInfo(upsertDeviceInfoDto: UpsertDeviceInfoDto, options?: any): AxiosPromise<DeviceInfoResponseDto> {
            return localVarFp.createDeviceInfo(upsertDeviceInfoDto, options).then((request) => request(axios, basePath));
        },
        /**
         * @deprecated
         * @param {UpsertDeviceInfoDto} upsertDeviceInfoDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceInfo(upsertDeviceInfoDto: UpsertDeviceInfoDto, options?: any): AxiosPromise<DeviceInfoResponseDto> {
            return localVarFp.updateDeviceInfo(upsertDeviceInfoDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpsertDeviceInfoDto} upsertDeviceInfoDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertDeviceInfo(upsertDeviceInfoDto: UpsertDeviceInfoDto, options?: any): AxiosPromise<DeviceInfoResponseDto> {
            return localVarFp.upsertDeviceInfo(upsertDeviceInfoDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeviceInfoApi - object-oriented interface
 * @export
 * @class DeviceInfoApi
 * @extends {BaseAPI}
 */
export class DeviceInfoApi extends BaseAPI {
    /**
     * @deprecated
     * @param {UpsertDeviceInfoDto} upsertDeviceInfoDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceInfoApi
     */
    public createDeviceInfo(upsertDeviceInfoDto: UpsertDeviceInfoDto, options?: AxiosRequestConfig) {
        return DeviceInfoApiFp(this.configuration).createDeviceInfo(upsertDeviceInfoDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * @deprecated
     * @param {UpsertDeviceInfoDto} upsertDeviceInfoDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceInfoApi
     */
    public updateDeviceInfo(upsertDeviceInfoDto: UpsertDeviceInfoDto, options?: AxiosRequestConfig) {
        return DeviceInfoApiFp(this.configuration).updateDeviceInfo(upsertDeviceInfoDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpsertDeviceInfoDto} upsertDeviceInfoDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceInfoApi
     */
    public upsertDeviceInfo(upsertDeviceInfoDto: UpsertDeviceInfoDto, options?: AxiosRequestConfig) {
        return DeviceInfoApiFp(this.configuration).upsertDeviceInfo(upsertDeviceInfoDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * JobApi - axios parameter creator
 * @export
 */
export const JobApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllJobsStatus: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/jobs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {JobId} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobStatus: async (jobId: JobId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getJobStatus', 'jobId', jobId)
            const localVarPath = `/jobs/{jobId}`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {JobId} jobId 
         * @param {JobCommandDto} jobCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendJobCommand: async (jobId: JobId, jobCommandDto: JobCommandDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('sendJobCommand', 'jobId', jobId)
            // verify required parameter 'jobCommandDto' is not null or undefined
            assertParamExists('sendJobCommand', 'jobCommandDto', jobCommandDto)
            const localVarPath = `/jobs/{jobId}`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jobCommandDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobApi - functional programming interface
 * @export
 */
export const JobApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JobApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllJobsStatus(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AllJobStatusResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllJobsStatus(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {JobId} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobStatus(jobId: JobId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobStatusResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobStatus(jobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {JobId} jobId 
         * @param {JobCommandDto} jobCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendJobCommand(jobId: JobId, jobCommandDto: JobCommandDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendJobCommand(jobId, jobCommandDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * JobApi - factory interface
 * @export
 */
export const JobApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JobApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllJobsStatus(options?: any): AxiosPromise<AllJobStatusResponseDto> {
            return localVarFp.getAllJobsStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {JobId} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobStatus(jobId: JobId, options?: any): AxiosPromise<JobStatusResponseDto> {
            return localVarFp.getJobStatus(jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {JobId} jobId 
         * @param {JobCommandDto} jobCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendJobCommand(jobId: JobId, jobCommandDto: JobCommandDto, options?: any): AxiosPromise<number> {
            return localVarFp.sendJobCommand(jobId, jobCommandDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JobApi - object-oriented interface
 * @export
 * @class JobApi
 * @extends {BaseAPI}
 */
export class JobApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public getAllJobsStatus(options?: AxiosRequestConfig) {
        return JobApiFp(this.configuration).getAllJobsStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {JobId} jobId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public getJobStatus(jobId: JobId, options?: AxiosRequestConfig) {
        return JobApiFp(this.configuration).getJobStatus(jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {JobId} jobId 
     * @param {JobCommandDto} jobCommandDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public sendJobCommand(jobId: JobId, jobCommandDto: JobCommandDto, options?: AxiosRequestConfig) {
        return JobApiFp(this.configuration).sendJobCommand(jobId, jobCommandDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OAuthApi - axios parameter creator
 * @export
 */
export const OAuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {OAuthCallbackDto} oAuthCallbackDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callback: async (oAuthCallbackDto: OAuthCallbackDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'oAuthCallbackDto' is not null or undefined
            assertParamExists('callback', 'oAuthCallbackDto', oAuthCallbackDto)
            const localVarPath = `/oauth/callback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(oAuthCallbackDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OAuthConfigDto} oAuthConfigDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateConfig: async (oAuthConfigDto: OAuthConfigDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'oAuthConfigDto' is not null or undefined
            assertParamExists('generateConfig', 'oAuthConfigDto', oAuthConfigDto)
            const localVarPath = `/oauth/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(oAuthConfigDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OAuthApi - functional programming interface
 * @export
 */
export const OAuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OAuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {OAuthCallbackDto} oAuthCallbackDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callback(oAuthCallbackDto: OAuthCallbackDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callback(oAuthCallbackDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {OAuthConfigDto} oAuthConfigDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateConfig(oAuthConfigDto: OAuthConfigDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OAuthConfigResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateConfig(oAuthConfigDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OAuthApi - factory interface
 * @export
 */
export const OAuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OAuthApiFp(configuration)
    return {
        /**
         * 
         * @param {OAuthCallbackDto} oAuthCallbackDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callback(oAuthCallbackDto: OAuthCallbackDto, options?: any): AxiosPromise<LoginResponseDto> {
            return localVarFp.callback(oAuthCallbackDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {OAuthConfigDto} oAuthConfigDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateConfig(oAuthConfigDto: OAuthConfigDto, options?: any): AxiosPromise<OAuthConfigResponseDto> {
            return localVarFp.generateConfig(oAuthConfigDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OAuthApi - object-oriented interface
 * @export
 * @class OAuthApi
 * @extends {BaseAPI}
 */
export class OAuthApi extends BaseAPI {
    /**
     * 
     * @param {OAuthCallbackDto} oAuthCallbackDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public callback(oAuthCallbackDto: OAuthCallbackDto, options?: AxiosRequestConfig) {
        return OAuthApiFp(this.configuration).callback(oAuthCallbackDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {OAuthConfigDto} oAuthConfigDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public generateConfig(oAuthConfigDto: OAuthConfigDto, options?: AxiosRequestConfig) {
        return OAuthApiFp(this.configuration).generateConfig(oAuthConfigDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ServerInfoApi - axios parameter creator
 * @export
 */
export const ServerInfoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerInfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/server-info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerVersion: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/server-info/version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/server-info/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pingServer: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/server-info/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServerInfoApi - functional programming interface
 * @export
 */
export const ServerInfoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServerInfoApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServerInfo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerInfoResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServerInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServerVersion(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerVersionReponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServerVersion(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStats(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerStatsResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStats(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pingServer(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerPingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pingServer(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ServerInfoApi - factory interface
 * @export
 */
export const ServerInfoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServerInfoApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerInfo(options?: any): AxiosPromise<ServerInfoResponseDto> {
            return localVarFp.getServerInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerVersion(options?: any): AxiosPromise<ServerVersionReponseDto> {
            return localVarFp.getServerVersion(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats(options?: any): AxiosPromise<ServerStatsResponseDto> {
            return localVarFp.getStats(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pingServer(options?: any): AxiosPromise<ServerPingResponse> {
            return localVarFp.pingServer(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServerInfoApi - object-oriented interface
 * @export
 * @class ServerInfoApi
 * @extends {BaseAPI}
 */
export class ServerInfoApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerInfoApi
     */
    public getServerInfo(options?: AxiosRequestConfig) {
        return ServerInfoApiFp(this.configuration).getServerInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerInfoApi
     */
    public getServerVersion(options?: AxiosRequestConfig) {
        return ServerInfoApiFp(this.configuration).getServerVersion(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerInfoApi
     */
    public getStats(options?: AxiosRequestConfig) {
        return ServerInfoApiFp(this.configuration).getStats(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerInfoApi
     */
    public pingServer(options?: AxiosRequestConfig) {
        return ServerInfoApiFp(this.configuration).pingServer(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SystemConfigApi - axios parameter creator
 * @export
 */
export const SystemConfigApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfig: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/system-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaults: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/system-config/defaults`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorageTemplateOptions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/system-config/storage-template-options`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SystemConfigDto} systemConfigDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConfig: async (systemConfigDto: SystemConfigDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'systemConfigDto' is not null or undefined
            assertParamExists('updateConfig', 'systemConfigDto', systemConfigDto)
            const localVarPath = `/system-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(systemConfigDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemConfigApi - functional programming interface
 * @export
 */
export const SystemConfigApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SystemConfigApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConfig(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemConfigDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConfig(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDefaults(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemConfigDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDefaults(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStorageTemplateOptions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemConfigTemplateStorageOptionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStorageTemplateOptions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SystemConfigDto} systemConfigDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateConfig(systemConfigDto: SystemConfigDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemConfigDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateConfig(systemConfigDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SystemConfigApi - factory interface
 * @export
 */
export const SystemConfigApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SystemConfigApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfig(options?: any): AxiosPromise<SystemConfigDto> {
            return localVarFp.getConfig(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaults(options?: any): AxiosPromise<SystemConfigDto> {
            return localVarFp.getDefaults(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorageTemplateOptions(options?: any): AxiosPromise<SystemConfigTemplateStorageOptionDto> {
            return localVarFp.getStorageTemplateOptions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SystemConfigDto} systemConfigDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConfig(systemConfigDto: SystemConfigDto, options?: any): AxiosPromise<SystemConfigDto> {
            return localVarFp.updateConfig(systemConfigDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SystemConfigApi - object-oriented interface
 * @export
 * @class SystemConfigApi
 * @extends {BaseAPI}
 */
export class SystemConfigApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemConfigApi
     */
    public getConfig(options?: AxiosRequestConfig) {
        return SystemConfigApiFp(this.configuration).getConfig(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemConfigApi
     */
    public getDefaults(options?: AxiosRequestConfig) {
        return SystemConfigApiFp(this.configuration).getDefaults(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemConfigApi
     */
    public getStorageTemplateOptions(options?: AxiosRequestConfig) {
        return SystemConfigApiFp(this.configuration).getStorageTemplateOptions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SystemConfigDto} systemConfigDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemConfigApi
     */
    public updateConfig(systemConfigDto: SystemConfigDto, options?: AxiosRequestConfig) {
        return SystemConfigApiFp(this.configuration).updateConfig(systemConfigDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TagApi - axios parameter creator
 * @export
 */
export const TagApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('_delete', 'id', id)
            const localVarPath = `/tag/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateTagDto} createTagDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (createTagDto: CreateTagDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTagDto' is not null or undefined
            assertParamExists('create', 'createTagDto', createTagDto)
            const localVarPath = `/tag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTagDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOne: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findOne', 'id', id)
            const localVarPath = `/tag/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateTagDto} updateTagDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (id: string, updateTagDto: UpdateTagDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update', 'id', id)
            // verify required parameter 'updateTagDto' is not null or undefined
            assertParamExists('update', 'updateTagDto', updateTagDto)
            const localVarPath = `/tag/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTagDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagApi - functional programming interface
 * @export
 */
export const TagApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CreateTagDto} createTagDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(createTagDto: CreateTagDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(createTagDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TagResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findOne(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findOne(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateTagDto} updateTagDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(id: string, updateTagDto: UpdateTagDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(id, updateTagDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TagApi - factory interface
 * @export
 */
export const TagApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp._delete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateTagDto} createTagDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(createTagDto: CreateTagDto, options?: any): AxiosPromise<TagResponseDto> {
            return localVarFp.create(createTagDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAll(options?: any): AxiosPromise<Array<TagResponseDto>> {
            return localVarFp.findAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOne(id: string, options?: any): AxiosPromise<TagResponseDto> {
            return localVarFp.findOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateTagDto} updateTagDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(id: string, updateTagDto: UpdateTagDto, options?: any): AxiosPromise<TagResponseDto> {
            return localVarFp.update(id, updateTagDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TagApi - object-oriented interface
 * @export
 * @class TagApi
 * @extends {BaseAPI}
 */
export class TagApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public _delete(id: string, options?: AxiosRequestConfig) {
        return TagApiFp(this.configuration)._delete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateTagDto} createTagDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public create(createTagDto: CreateTagDto, options?: AxiosRequestConfig) {
        return TagApiFp(this.configuration).create(createTagDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public findAll(options?: AxiosRequestConfig) {
        return TagApiFp(this.configuration).findAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public findOne(id: string, options?: AxiosRequestConfig) {
        return TagApiFp(this.configuration).findOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateTagDto} updateTagDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public update(id: string, updateTagDto: UpdateTagDto, options?: AxiosRequestConfig) {
        return TagApiFp(this.configuration).update(id, updateTagDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {any} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProfileImage: async (file: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('createProfileImage', 'file', file)
            const localVarPath = `/user/profile-image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (createUserDto: CreateUserDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createUserDto' is not null or undefined
            assertParamExists('createUser', 'createUserDto', createUserDto)
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUser', 'userId', userId)
            const localVarPath = `/user/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} isAll 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers: async (isAll: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'isAll' is not null or undefined
            assertParamExists('getAllUsers', 'isAll', isAll)
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (isAll !== undefined) {
                localVarQueryParameter['isAll'] = isAll;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyUserInfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfileImage: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getProfileImage', 'userId', userId)
            const localVarPath = `/user/profile-image/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserById', 'userId', userId)
            const localVarPath = `/user/info/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} [admin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCount: async (admin?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (admin !== undefined) {
                localVarQueryParameter['admin'] = admin;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreUser: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('restoreUser', 'userId', userId)
            const localVarPath = `/user/{userId}/restore`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (updateUserDto: UpdateUserDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateUserDto' is not null or undefined
            assertParamExists('updateUser', 'updateUserDto', updateUserDto)
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {any} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProfileImage(file: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateProfileImageResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProfileImage(file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(createUserDto: CreateUserDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(createUserDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {boolean} isAll 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllUsers(isAll: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllUsers(isAll, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMyUserInfo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMyUserInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfileImage(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProfileImage(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserById(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserById(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {boolean} [admin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserCount(admin?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCountResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserCount(admin, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreUser(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreUser(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(updateUserDto: UpdateUserDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(updateUserDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @param {any} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProfileImage(file: any, options?: any): AxiosPromise<CreateProfileImageResponseDto> {
            return localVarFp.createProfileImage(file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(createUserDto: CreateUserDto, options?: any): AxiosPromise<UserResponseDto> {
            return localVarFp.createUser(createUserDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(userId: string, options?: any): AxiosPromise<UserResponseDto> {
            return localVarFp.deleteUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} isAll 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers(isAll: boolean, options?: any): AxiosPromise<Array<UserResponseDto>> {
            return localVarFp.getAllUsers(isAll, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyUserInfo(options?: any): AxiosPromise<UserResponseDto> {
            return localVarFp.getMyUserInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfileImage(userId: string, options?: any): AxiosPromise<object> {
            return localVarFp.getProfileImage(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById(userId: string, options?: any): AxiosPromise<UserResponseDto> {
            return localVarFp.getUserById(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} [admin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCount(admin?: boolean, options?: any): AxiosPromise<UserCountResponseDto> {
            return localVarFp.getUserCount(admin, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreUser(userId: string, options?: any): AxiosPromise<UserResponseDto> {
            return localVarFp.restoreUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(updateUserDto: UpdateUserDto, options?: any): AxiosPromise<UserResponseDto> {
            return localVarFp.updateUser(updateUserDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @param {any} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public createProfileImage(file: any, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).createProfileImage(file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateUserDto} createUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public createUser(createUserDto: CreateUserDto, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).createUser(createUserDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public deleteUser(userId: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).deleteUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {boolean} isAll 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getAllUsers(isAll: boolean, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getAllUsers(isAll, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getMyUserInfo(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getMyUserInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getProfileImage(userId: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getProfileImage(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserById(userId: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserById(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {boolean} [admin] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserCount(admin?: boolean, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserCount(admin, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public restoreUser(userId: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).restoreUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateUserDto} updateUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUser(updateUserDto: UpdateUserDto, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).updateUser(updateUserDto, options).then((request) => request(this.axios, this.basePath));
    }
}


