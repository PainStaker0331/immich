/* tslint:disable */
/* eslint-disable */
/**
 * Immich
 * Immich API
 *
 * The version of the OpenAPI document: 1.52.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface APIKeyCreateDto
 */
export interface APIKeyCreateDto {
    /**
     * 
     * @type {string}
     * @memberof APIKeyCreateDto
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface APIKeyCreateResponseDto
 */
export interface APIKeyCreateResponseDto {
    /**
     * 
     * @type {string}
     * @memberof APIKeyCreateResponseDto
     */
    'secret': string;
    /**
     * 
     * @type {APIKeyResponseDto}
     * @memberof APIKeyCreateResponseDto
     */
    'apiKey': APIKeyResponseDto;
}
/**
 * 
 * @export
 * @interface APIKeyResponseDto
 */
export interface APIKeyResponseDto {
    /**
     * 
     * @type {string}
     * @memberof APIKeyResponseDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof APIKeyResponseDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof APIKeyResponseDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof APIKeyResponseDto
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface APIKeyUpdateDto
 */
export interface APIKeyUpdateDto {
    /**
     * 
     * @type {string}
     * @memberof APIKeyUpdateDto
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface AddAssetsDto
 */
export interface AddAssetsDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof AddAssetsDto
     */
    'assetIds': Array<string>;
}
/**
 * 
 * @export
 * @interface AddAssetsResponseDto
 */
export interface AddAssetsResponseDto {
    /**
     * 
     * @type {number}
     * @memberof AddAssetsResponseDto
     */
    'successfullyAdded': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof AddAssetsResponseDto
     */
    'alreadyInAlbum': Array<string>;
    /**
     * 
     * @type {AlbumResponseDto}
     * @memberof AddAssetsResponseDto
     */
    'album'?: AlbumResponseDto;
}
/**
 * 
 * @export
 * @interface AddUsersDto
 */
export interface AddUsersDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof AddUsersDto
     */
    'sharedUserIds': Array<string>;
}
/**
 * 
 * @export
 * @interface AdminSignupResponseDto
 */
export interface AdminSignupResponseDto {
    /**
     * 
     * @type {string}
     * @memberof AdminSignupResponseDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AdminSignupResponseDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof AdminSignupResponseDto
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof AdminSignupResponseDto
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof AdminSignupResponseDto
     */
    'createdAt': string;
}
/**
 * 
 * @export
 * @interface AlbumCountResponseDto
 */
export interface AlbumCountResponseDto {
    /**
     * 
     * @type {number}
     * @memberof AlbumCountResponseDto
     */
    'owned': number;
    /**
     * 
     * @type {number}
     * @memberof AlbumCountResponseDto
     */
    'shared': number;
    /**
     * 
     * @type {number}
     * @memberof AlbumCountResponseDto
     */
    'sharing': number;
}
/**
 * 
 * @export
 * @interface AlbumResponseDto
 */
export interface AlbumResponseDto {
    /**
     * 
     * @type {number}
     * @memberof AlbumResponseDto
     */
    'assetCount': number;
    /**
     * 
     * @type {string}
     * @memberof AlbumResponseDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AlbumResponseDto
     */
    'ownerId': string;
    /**
     * 
     * @type {string}
     * @memberof AlbumResponseDto
     */
    'albumName': string;
    /**
     * 
     * @type {string}
     * @memberof AlbumResponseDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof AlbumResponseDto
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof AlbumResponseDto
     */
    'albumThumbnailAssetId': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof AlbumResponseDto
     */
    'shared': boolean;
    /**
     * 
     * @type {Array<UserResponseDto>}
     * @memberof AlbumResponseDto
     */
    'sharedUsers': Array<UserResponseDto>;
    /**
     * 
     * @type {Array<AssetResponseDto>}
     * @memberof AlbumResponseDto
     */
    'assets': Array<AssetResponseDto>;
    /**
     * 
     * @type {UserResponseDto}
     * @memberof AlbumResponseDto
     */
    'owner': UserResponseDto;
}
/**
 * 
 * @export
 * @interface AllJobStatusResponseDto
 */
export interface AllJobStatusResponseDto {
    /**
     * 
     * @type {JobCountsDto}
     * @memberof AllJobStatusResponseDto
     */
    'thumbnail-generation-queue': JobCountsDto;
    /**
     * 
     * @type {JobCountsDto}
     * @memberof AllJobStatusResponseDto
     */
    'metadata-extraction-queue': JobCountsDto;
    /**
     * 
     * @type {JobCountsDto}
     * @memberof AllJobStatusResponseDto
     */
    'video-conversion-queue': JobCountsDto;
    /**
     * 
     * @type {JobCountsDto}
     * @memberof AllJobStatusResponseDto
     */
    'object-tagging-queue': JobCountsDto;
    /**
     * 
     * @type {JobCountsDto}
     * @memberof AllJobStatusResponseDto
     */
    'clip-encoding-queue': JobCountsDto;
    /**
     * 
     * @type {JobCountsDto}
     * @memberof AllJobStatusResponseDto
     */
    'storage-template-migration-queue': JobCountsDto;
    /**
     * 
     * @type {JobCountsDto}
     * @memberof AllJobStatusResponseDto
     */
    'background-task-queue': JobCountsDto;
    /**
     * 
     * @type {JobCountsDto}
     * @memberof AllJobStatusResponseDto
     */
    'search-queue': JobCountsDto;
}
/**
 * 
 * @export
 * @interface AssetCountByTimeBucket
 */
export interface AssetCountByTimeBucket {
    /**
     * 
     * @type {string}
     * @memberof AssetCountByTimeBucket
     */
    'timeBucket': string;
    /**
     * 
     * @type {number}
     * @memberof AssetCountByTimeBucket
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface AssetCountByTimeBucketResponseDto
 */
export interface AssetCountByTimeBucketResponseDto {
    /**
     * 
     * @type {number}
     * @memberof AssetCountByTimeBucketResponseDto
     */
    'totalCount': number;
    /**
     * 
     * @type {Array<AssetCountByTimeBucket>}
     * @memberof AssetCountByTimeBucketResponseDto
     */
    'buckets': Array<AssetCountByTimeBucket>;
}
/**
 * 
 * @export
 * @interface AssetCountByUserIdResponseDto
 */
export interface AssetCountByUserIdResponseDto {
    /**
     * 
     * @type {number}
     * @memberof AssetCountByUserIdResponseDto
     */
    'audio': number;
    /**
     * 
     * @type {number}
     * @memberof AssetCountByUserIdResponseDto
     */
    'photos': number;
    /**
     * 
     * @type {number}
     * @memberof AssetCountByUserIdResponseDto
     */
    'videos': number;
    /**
     * 
     * @type {number}
     * @memberof AssetCountByUserIdResponseDto
     */
    'other': number;
    /**
     * 
     * @type {number}
     * @memberof AssetCountByUserIdResponseDto
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface AssetFileUploadResponseDto
 */
export interface AssetFileUploadResponseDto {
    /**
     * 
     * @type {string}
     * @memberof AssetFileUploadResponseDto
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof AssetFileUploadResponseDto
     */
    'duplicate': boolean;
}
/**
 * 
 * @export
 * @interface AssetResponseDto
 */
export interface AssetResponseDto {
    /**
     * 
     * @type {AssetTypeEnum}
     * @memberof AssetResponseDto
     */
    'type': AssetTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof AssetResponseDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AssetResponseDto
     */
    'deviceAssetId': string;
    /**
     * 
     * @type {string}
     * @memberof AssetResponseDto
     */
    'ownerId': string;
    /**
     * 
     * @type {string}
     * @memberof AssetResponseDto
     */
    'deviceId': string;
    /**
     * 
     * @type {string}
     * @memberof AssetResponseDto
     */
    'originalPath': string;
    /**
     * 
     * @type {string}
     * @memberof AssetResponseDto
     */
    'resizePath': string | null;
    /**
     * 
     * @type {string}
     * @memberof AssetResponseDto
     */
    'fileCreatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof AssetResponseDto
     */
    'fileModifiedAt': string;
    /**
     * 
     * @type {string}
     * @memberof AssetResponseDto
     */
    'updatedAt': string;
    /**
     * 
     * @type {boolean}
     * @memberof AssetResponseDto
     */
    'isFavorite': boolean;
    /**
     * 
     * @type {string}
     * @memberof AssetResponseDto
     */
    'mimeType': string | null;
    /**
     * 
     * @type {string}
     * @memberof AssetResponseDto
     */
    'duration': string;
    /**
     * 
     * @type {string}
     * @memberof AssetResponseDto
     */
    'webpPath': string | null;
    /**
     * 
     * @type {string}
     * @memberof AssetResponseDto
     */
    'encodedVideoPath'?: string | null;
    /**
     * 
     * @type {ExifResponseDto}
     * @memberof AssetResponseDto
     */
    'exifInfo'?: ExifResponseDto;
    /**
     * 
     * @type {SmartInfoResponseDto}
     * @memberof AssetResponseDto
     */
    'smartInfo'?: SmartInfoResponseDto;
    /**
     * 
     * @type {string}
     * @memberof AssetResponseDto
     */
    'livePhotoVideoId'?: string | null;
    /**
     * 
     * @type {Array<TagResponseDto>}
     * @memberof AssetResponseDto
     */
    'tags'?: Array<TagResponseDto>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const AssetTypeEnum = {
    Image: 'IMAGE',
    Video: 'VIDEO',
    Audio: 'AUDIO',
    Other: 'OTHER'
} as const;

export type AssetTypeEnum = typeof AssetTypeEnum[keyof typeof AssetTypeEnum];


/**
 * 
 * @export
 * @interface ChangePasswordDto
 */
export interface ChangePasswordDto {
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordDto
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordDto
     */
    'newPassword': string;
}
/**
 * 
 * @export
 * @interface CheckDuplicateAssetDto
 */
export interface CheckDuplicateAssetDto {
    /**
     * 
     * @type {string}
     * @memberof CheckDuplicateAssetDto
     */
    'deviceAssetId': string;
    /**
     * 
     * @type {string}
     * @memberof CheckDuplicateAssetDto
     */
    'deviceId': string;
}
/**
 * 
 * @export
 * @interface CheckDuplicateAssetResponseDto
 */
export interface CheckDuplicateAssetResponseDto {
    /**
     * 
     * @type {boolean}
     * @memberof CheckDuplicateAssetResponseDto
     */
    'isExist': boolean;
    /**
     * 
     * @type {string}
     * @memberof CheckDuplicateAssetResponseDto
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface CheckExistingAssetsDto
 */
export interface CheckExistingAssetsDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof CheckExistingAssetsDto
     */
    'deviceAssetIds': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CheckExistingAssetsDto
     */
    'deviceId': string;
}
/**
 * 
 * @export
 * @interface CheckExistingAssetsResponseDto
 */
export interface CheckExistingAssetsResponseDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof CheckExistingAssetsResponseDto
     */
    'existingIds': Array<string>;
}
/**
 * 
 * @export
 * @interface CreateAlbumDto
 */
export interface CreateAlbumDto {
    /**
     * 
     * @type {string}
     * @memberof CreateAlbumDto
     */
    'albumName': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateAlbumDto
     */
    'sharedWithUserIds'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateAlbumDto
     */
    'assetIds'?: Array<string>;
}
/**
 * 
 * @export
 * @interface CreateAlbumShareLinkDto
 */
export interface CreateAlbumShareLinkDto {
    /**
     * 
     * @type {string}
     * @memberof CreateAlbumShareLinkDto
     */
    'albumId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateAlbumShareLinkDto
     */
    'expiresAt'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateAlbumShareLinkDto
     */
    'allowUpload'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateAlbumShareLinkDto
     */
    'allowDownload'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateAlbumShareLinkDto
     */
    'showExif'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateAlbumShareLinkDto
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface CreateAssetsShareLinkDto
 */
export interface CreateAssetsShareLinkDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateAssetsShareLinkDto
     */
    'assetIds': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CreateAssetsShareLinkDto
     */
    'expiresAt'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateAssetsShareLinkDto
     */
    'allowUpload'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateAssetsShareLinkDto
     */
    'allowDownload'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateAssetsShareLinkDto
     */
    'showExif'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateAssetsShareLinkDto
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface CreateProfileImageResponseDto
 */
export interface CreateProfileImageResponseDto {
    /**
     * 
     * @type {string}
     * @memberof CreateProfileImageResponseDto
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateProfileImageResponseDto
     */
    'profileImagePath': string;
}
/**
 * 
 * @export
 * @interface CreateTagDto
 */
export interface CreateTagDto {
    /**
     * 
     * @type {TagTypeEnum}
     * @memberof CreateTagDto
     */
    'type': TagTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateTagDto
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface CreateUserDto
 */
export interface CreateUserDto {
    /**
     * 
     * @type {string}
     * @memberof CreateUserDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserDto
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserDto
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserDto
     */
    'lastName': string;
}
/**
 * 
 * @export
 * @interface CuratedLocationsResponseDto
 */
export interface CuratedLocationsResponseDto {
    /**
     * 
     * @type {string}
     * @memberof CuratedLocationsResponseDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CuratedLocationsResponseDto
     */
    'city': string;
    /**
     * 
     * @type {string}
     * @memberof CuratedLocationsResponseDto
     */
    'resizePath': string;
    /**
     * 
     * @type {string}
     * @memberof CuratedLocationsResponseDto
     */
    'deviceAssetId': string;
    /**
     * 
     * @type {string}
     * @memberof CuratedLocationsResponseDto
     */
    'deviceId': string;
}
/**
 * 
 * @export
 * @interface CuratedObjectsResponseDto
 */
export interface CuratedObjectsResponseDto {
    /**
     * 
     * @type {string}
     * @memberof CuratedObjectsResponseDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CuratedObjectsResponseDto
     */
    'object': string;
    /**
     * 
     * @type {string}
     * @memberof CuratedObjectsResponseDto
     */
    'resizePath': string;
    /**
     * 
     * @type {string}
     * @memberof CuratedObjectsResponseDto
     */
    'deviceAssetId': string;
    /**
     * 
     * @type {string}
     * @memberof CuratedObjectsResponseDto
     */
    'deviceId': string;
}
/**
 * 
 * @export
 * @interface DeleteAssetDto
 */
export interface DeleteAssetDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof DeleteAssetDto
     */
    'ids': Array<string>;
}
/**
 * 
 * @export
 * @interface DeleteAssetResponseDto
 */
export interface DeleteAssetResponseDto {
    /**
     * 
     * @type {DeleteAssetStatus}
     * @memberof DeleteAssetResponseDto
     */
    'status': DeleteAssetStatus;
    /**
     * 
     * @type {string}
     * @memberof DeleteAssetResponseDto
     */
    'id': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const DeleteAssetStatus = {
    Success: 'SUCCESS',
    Failed: 'FAILED'
} as const;

export type DeleteAssetStatus = typeof DeleteAssetStatus[keyof typeof DeleteAssetStatus];


/**
 * 
 * @export
 * @interface DeviceInfoResponseDto
 */
export interface DeviceInfoResponseDto {
    /**
     * 
     * @type {number}
     * @memberof DeviceInfoResponseDto
     */
    'id': number;
    /**
     * 
     * @type {DeviceTypeEnum}
     * @memberof DeviceInfoResponseDto
     */
    'deviceType': DeviceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof DeviceInfoResponseDto
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof DeviceInfoResponseDto
     */
    'deviceId': string;
    /**
     * 
     * @type {string}
     * @memberof DeviceInfoResponseDto
     */
    'createdAt': string;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceInfoResponseDto
     */
    'isAutoBackup': boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const DeviceTypeEnum = {
    Ios: 'IOS',
    Android: 'ANDROID',
    Web: 'WEB'
} as const;

export type DeviceTypeEnum = typeof DeviceTypeEnum[keyof typeof DeviceTypeEnum];


/**
 * 
 * @export
 * @interface DownloadFilesDto
 */
export interface DownloadFilesDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof DownloadFilesDto
     */
    'assetIds': Array<string>;
}
/**
 * 
 * @export
 * @interface EditSharedLinkDto
 */
export interface EditSharedLinkDto {
    /**
     * 
     * @type {string}
     * @memberof EditSharedLinkDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof EditSharedLinkDto
     */
    'expiresAt'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof EditSharedLinkDto
     */
    'allowUpload'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EditSharedLinkDto
     */
    'allowDownload'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EditSharedLinkDto
     */
    'showExif'?: boolean;
}
/**
 * 
 * @export
 * @interface ExifResponseDto
 */
export interface ExifResponseDto {
    /**
     * 
     * @type {number}
     * @memberof ExifResponseDto
     */
    'fileSizeInByte'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ExifResponseDto
     */
    'make'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExifResponseDto
     */
    'model'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExifResponseDto
     */
    'imageName'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ExifResponseDto
     */
    'exifImageWidth'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ExifResponseDto
     */
    'exifImageHeight'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ExifResponseDto
     */
    'orientation'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExifResponseDto
     */
    'dateTimeOriginal'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExifResponseDto
     */
    'modifyDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExifResponseDto
     */
    'lensModel'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ExifResponseDto
     */
    'fNumber'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ExifResponseDto
     */
    'focalLength'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ExifResponseDto
     */
    'iso'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ExifResponseDto
     */
    'exposureTime'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ExifResponseDto
     */
    'latitude'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ExifResponseDto
     */
    'longitude'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ExifResponseDto
     */
    'city'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExifResponseDto
     */
    'state'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExifResponseDto
     */
    'country'?: string | null;
}
/**
 * 
 * @export
 * @interface GetAssetByTimeBucketDto
 */
export interface GetAssetByTimeBucketDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof GetAssetByTimeBucketDto
     */
    'timeBucket': Array<string>;
}
/**
 * 
 * @export
 * @interface GetAssetCountByTimeBucketDto
 */
export interface GetAssetCountByTimeBucketDto {
    /**
     * 
     * @type {TimeGroupEnum}
     * @memberof GetAssetCountByTimeBucketDto
     */
    'timeGroup': TimeGroupEnum;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const JobCommand = {
    Start: 'start',
    Pause: 'pause',
    Resume: 'resume',
    Empty: 'empty'
} as const;

export type JobCommand = typeof JobCommand[keyof typeof JobCommand];


/**
 * 
 * @export
 * @interface JobCommandDto
 */
export interface JobCommandDto {
    /**
     * 
     * @type {JobCommand}
     * @memberof JobCommandDto
     */
    'command': JobCommand;
    /**
     * 
     * @type {boolean}
     * @memberof JobCommandDto
     */
    'force': boolean;
}
/**
 * 
 * @export
 * @interface JobCountsDto
 */
export interface JobCountsDto {
    /**
     * 
     * @type {number}
     * @memberof JobCountsDto
     */
    'active': number;
    /**
     * 
     * @type {number}
     * @memberof JobCountsDto
     */
    'completed': number;
    /**
     * 
     * @type {number}
     * @memberof JobCountsDto
     */
    'failed': number;
    /**
     * 
     * @type {number}
     * @memberof JobCountsDto
     */
    'delayed': number;
    /**
     * 
     * @type {number}
     * @memberof JobCountsDto
     */
    'waiting': number;
    /**
     * 
     * @type {number}
     * @memberof JobCountsDto
     */
    'paused': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const JobName = {
    ThumbnailGenerationQueue: 'thumbnail-generation-queue',
    MetadataExtractionQueue: 'metadata-extraction-queue',
    VideoConversionQueue: 'video-conversion-queue',
    ObjectTaggingQueue: 'object-tagging-queue',
    ClipEncodingQueue: 'clip-encoding-queue',
    BackgroundTaskQueue: 'background-task-queue',
    StorageTemplateMigrationQueue: 'storage-template-migration-queue',
    SearchQueue: 'search-queue'
} as const;

export type JobName = typeof JobName[keyof typeof JobName];


/**
 * 
 * @export
 * @interface LoginCredentialDto
 */
export interface LoginCredentialDto {
    /**
     * 
     * @type {string}
     * @memberof LoginCredentialDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof LoginCredentialDto
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface LoginResponseDto
 */
export interface LoginResponseDto {
    /**
     * 
     * @type {string}
     * @memberof LoginResponseDto
     */
    'accessToken': string;
    /**
     * 
     * @type {string}
     * @memberof LoginResponseDto
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof LoginResponseDto
     */
    'userEmail': string;
    /**
     * 
     * @type {string}
     * @memberof LoginResponseDto
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof LoginResponseDto
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof LoginResponseDto
     */
    'profileImagePath': string;
    /**
     * 
     * @type {boolean}
     * @memberof LoginResponseDto
     */
    'isAdmin': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LoginResponseDto
     */
    'shouldChangePassword': boolean;
}
/**
 * 
 * @export
 * @interface LogoutResponseDto
 */
export interface LogoutResponseDto {
    /**
     * 
     * @type {boolean}
     * @memberof LogoutResponseDto
     */
    'successful': boolean;
    /**
     * 
     * @type {string}
     * @memberof LogoutResponseDto
     */
    'redirectUri': string;
}
/**
 * 
 * @export
 * @interface OAuthCallbackDto
 */
export interface OAuthCallbackDto {
    /**
     * 
     * @type {string}
     * @memberof OAuthCallbackDto
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface OAuthConfigDto
 */
export interface OAuthConfigDto {
    /**
     * 
     * @type {string}
     * @memberof OAuthConfigDto
     */
    'redirectUri': string;
}
/**
 * 
 * @export
 * @interface OAuthConfigResponseDto
 */
export interface OAuthConfigResponseDto {
    /**
     * 
     * @type {boolean}
     * @memberof OAuthConfigResponseDto
     */
    'enabled': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OAuthConfigResponseDto
     */
    'passwordLoginEnabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof OAuthConfigResponseDto
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuthConfigResponseDto
     */
    'buttonText'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OAuthConfigResponseDto
     */
    'autoLaunch'?: boolean;
}
/**
 * 
 * @export
 * @interface RemoveAssetsDto
 */
export interface RemoveAssetsDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof RemoveAssetsDto
     */
    'assetIds': Array<string>;
}
/**
 * 
 * @export
 * @interface SearchAlbumResponseDto
 */
export interface SearchAlbumResponseDto {
    /**
     * 
     * @type {number}
     * @memberof SearchAlbumResponseDto
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof SearchAlbumResponseDto
     */
    'count': number;
    /**
     * 
     * @type {Array<AlbumResponseDto>}
     * @memberof SearchAlbumResponseDto
     */
    'items': Array<AlbumResponseDto>;
    /**
     * 
     * @type {Array<SearchFacetResponseDto>}
     * @memberof SearchAlbumResponseDto
     */
    'facets': Array<SearchFacetResponseDto>;
}
/**
 * 
 * @export
 * @interface SearchAssetDto
 */
export interface SearchAssetDto {
    /**
     * 
     * @type {string}
     * @memberof SearchAssetDto
     */
    'searchTerm': string;
}
/**
 * 
 * @export
 * @interface SearchAssetResponseDto
 */
export interface SearchAssetResponseDto {
    /**
     * 
     * @type {number}
     * @memberof SearchAssetResponseDto
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof SearchAssetResponseDto
     */
    'count': number;
    /**
     * 
     * @type {Array<AssetResponseDto>}
     * @memberof SearchAssetResponseDto
     */
    'items': Array<AssetResponseDto>;
    /**
     * 
     * @type {Array<SearchFacetResponseDto>}
     * @memberof SearchAssetResponseDto
     */
    'facets': Array<SearchFacetResponseDto>;
}
/**
 * 
 * @export
 * @interface SearchConfigResponseDto
 */
export interface SearchConfigResponseDto {
    /**
     * 
     * @type {boolean}
     * @memberof SearchConfigResponseDto
     */
    'enabled': boolean;
}
/**
 * 
 * @export
 * @interface SearchExploreItem
 */
export interface SearchExploreItem {
    /**
     * 
     * @type {string}
     * @memberof SearchExploreItem
     */
    'value': string;
    /**
     * 
     * @type {AssetResponseDto}
     * @memberof SearchExploreItem
     */
    'data': AssetResponseDto;
}
/**
 * 
 * @export
 * @interface SearchExploreResponseDto
 */
export interface SearchExploreResponseDto {
    /**
     * 
     * @type {string}
     * @memberof SearchExploreResponseDto
     */
    'fieldName': string;
    /**
     * 
     * @type {Array<SearchExploreItem>}
     * @memberof SearchExploreResponseDto
     */
    'items': Array<SearchExploreItem>;
}
/**
 * 
 * @export
 * @interface SearchFacetCountResponseDto
 */
export interface SearchFacetCountResponseDto {
    /**
     * 
     * @type {number}
     * @memberof SearchFacetCountResponseDto
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof SearchFacetCountResponseDto
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface SearchFacetResponseDto
 */
export interface SearchFacetResponseDto {
    /**
     * 
     * @type {string}
     * @memberof SearchFacetResponseDto
     */
    'fieldName': string;
    /**
     * 
     * @type {Array<SearchFacetCountResponseDto>}
     * @memberof SearchFacetResponseDto
     */
    'counts': Array<SearchFacetCountResponseDto>;
}
/**
 * 
 * @export
 * @interface SearchResponseDto
 */
export interface SearchResponseDto {
    /**
     * 
     * @type {SearchAlbumResponseDto}
     * @memberof SearchResponseDto
     */
    'albums': SearchAlbumResponseDto;
    /**
     * 
     * @type {SearchAssetResponseDto}
     * @memberof SearchResponseDto
     */
    'assets': SearchAssetResponseDto;
}
/**
 * 
 * @export
 * @interface ServerInfoResponseDto
 */
export interface ServerInfoResponseDto {
    /**
     * 
     * @type {number}
     * @memberof ServerInfoResponseDto
     */
    'diskSizeRaw': number;
    /**
     * 
     * @type {number}
     * @memberof ServerInfoResponseDto
     */
    'diskUseRaw': number;
    /**
     * 
     * @type {number}
     * @memberof ServerInfoResponseDto
     */
    'diskAvailableRaw': number;
    /**
     * 
     * @type {number}
     * @memberof ServerInfoResponseDto
     */
    'diskUsagePercentage': number;
    /**
     * 
     * @type {string}
     * @memberof ServerInfoResponseDto
     */
    'diskSize': string;
    /**
     * 
     * @type {string}
     * @memberof ServerInfoResponseDto
     */
    'diskUse': string;
    /**
     * 
     * @type {string}
     * @memberof ServerInfoResponseDto
     */
    'diskAvailable': string;
}
/**
 * 
 * @export
 * @interface ServerPingResponse
 */
export interface ServerPingResponse {
    /**
     * 
     * @type {string}
     * @memberof ServerPingResponse
     */
    'res': string;
}
/**
 * 
 * @export
 * @interface ServerStatsResponseDto
 */
export interface ServerStatsResponseDto {
    /**
     * 
     * @type {number}
     * @memberof ServerStatsResponseDto
     */
    'photos': number;
    /**
     * 
     * @type {number}
     * @memberof ServerStatsResponseDto
     */
    'videos': number;
    /**
     * 
     * @type {number}
     * @memberof ServerStatsResponseDto
     */
    'usage': number;
    /**
     * 
     * @type {Array<UsageByUserDto>}
     * @memberof ServerStatsResponseDto
     */
    'usageByUser': Array<UsageByUserDto>;
}
/**
 * 
 * @export
 * @interface ServerVersionReponseDto
 */
export interface ServerVersionReponseDto {
    /**
     * 
     * @type {number}
     * @memberof ServerVersionReponseDto
     */
    'major': number;
    /**
     * 
     * @type {number}
     * @memberof ServerVersionReponseDto
     */
    'minor': number;
    /**
     * 
     * @type {number}
     * @memberof ServerVersionReponseDto
     */
    'patch': number;
}
/**
 * 
 * @export
 * @interface SharedLinkResponseDto
 */
export interface SharedLinkResponseDto {
    /**
     * 
     * @type {SharedLinkType}
     * @memberof SharedLinkResponseDto
     */
    'type': SharedLinkType;
    /**
     * 
     * @type {string}
     * @memberof SharedLinkResponseDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SharedLinkResponseDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof SharedLinkResponseDto
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof SharedLinkResponseDto
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof SharedLinkResponseDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof SharedLinkResponseDto
     */
    'expiresAt': string | null;
    /**
     * 
     * @type {Array<AssetResponseDto>}
     * @memberof SharedLinkResponseDto
     */
    'assets': Array<AssetResponseDto>;
    /**
     * 
     * @type {AlbumResponseDto}
     * @memberof SharedLinkResponseDto
     */
    'album'?: AlbumResponseDto;
    /**
     * 
     * @type {boolean}
     * @memberof SharedLinkResponseDto
     */
    'allowUpload': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SharedLinkResponseDto
     */
    'allowDownload': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SharedLinkResponseDto
     */
    'showExif': boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const SharedLinkType = {
    Album: 'ALBUM',
    Individual: 'INDIVIDUAL'
} as const;

export type SharedLinkType = typeof SharedLinkType[keyof typeof SharedLinkType];


/**
 * 
 * @export
 * @interface SignUpDto
 */
export interface SignUpDto {
    /**
     * 
     * @type {string}
     * @memberof SignUpDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpDto
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpDto
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpDto
     */
    'lastName': string;
}
/**
 * 
 * @export
 * @interface SmartInfoResponseDto
 */
export interface SmartInfoResponseDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof SmartInfoResponseDto
     */
    'tags'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof SmartInfoResponseDto
     */
    'objects'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface SystemConfigDto
 */
export interface SystemConfigDto {
    /**
     * 
     * @type {SystemConfigFFmpegDto}
     * @memberof SystemConfigDto
     */
    'ffmpeg': SystemConfigFFmpegDto;
    /**
     * 
     * @type {SystemConfigOAuthDto}
     * @memberof SystemConfigDto
     */
    'oauth': SystemConfigOAuthDto;
    /**
     * 
     * @type {SystemConfigPasswordLoginDto}
     * @memberof SystemConfigDto
     */
    'passwordLogin': SystemConfigPasswordLoginDto;
    /**
     * 
     * @type {SystemConfigStorageTemplateDto}
     * @memberof SystemConfigDto
     */
    'storageTemplate': SystemConfigStorageTemplateDto;
}
/**
 * 
 * @export
 * @interface SystemConfigFFmpegDto
 */
export interface SystemConfigFFmpegDto {
    /**
     * 
     * @type {string}
     * @memberof SystemConfigFFmpegDto
     */
    'crf': string;
    /**
     * 
     * @type {string}
     * @memberof SystemConfigFFmpegDto
     */
    'preset': string;
    /**
     * 
     * @type {string}
     * @memberof SystemConfigFFmpegDto
     */
    'targetVideoCodec': string;
    /**
     * 
     * @type {string}
     * @memberof SystemConfigFFmpegDto
     */
    'targetAudioCodec': string;
    /**
     * 
     * @type {string}
     * @memberof SystemConfigFFmpegDto
     */
    'targetScaling': string;
    /**
     * 
     * @type {string}
     * @memberof SystemConfigFFmpegDto
     */
    'transcode': SystemConfigFFmpegDtoTranscodeEnum;
}

export const SystemConfigFFmpegDtoTranscodeEnum = {
    All: 'all',
    Optimal: 'optimal',
    Required: 'required'
} as const;

export type SystemConfigFFmpegDtoTranscodeEnum = typeof SystemConfigFFmpegDtoTranscodeEnum[keyof typeof SystemConfigFFmpegDtoTranscodeEnum];

/**
 * 
 * @export
 * @interface SystemConfigOAuthDto
 */
export interface SystemConfigOAuthDto {
    /**
     * 
     * @type {boolean}
     * @memberof SystemConfigOAuthDto
     */
    'enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof SystemConfigOAuthDto
     */
    'issuerUrl': string;
    /**
     * 
     * @type {string}
     * @memberof SystemConfigOAuthDto
     */
    'clientId': string;
    /**
     * 
     * @type {string}
     * @memberof SystemConfigOAuthDto
     */
    'clientSecret': string;
    /**
     * 
     * @type {string}
     * @memberof SystemConfigOAuthDto
     */
    'scope': string;
    /**
     * 
     * @type {string}
     * @memberof SystemConfigOAuthDto
     */
    'buttonText': string;
    /**
     * 
     * @type {boolean}
     * @memberof SystemConfigOAuthDto
     */
    'autoRegister': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SystemConfigOAuthDto
     */
    'autoLaunch': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SystemConfigOAuthDto
     */
    'mobileOverrideEnabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof SystemConfigOAuthDto
     */
    'mobileRedirectUri': string;
}
/**
 * 
 * @export
 * @interface SystemConfigPasswordLoginDto
 */
export interface SystemConfigPasswordLoginDto {
    /**
     * 
     * @type {boolean}
     * @memberof SystemConfigPasswordLoginDto
     */
    'enabled': boolean;
}
/**
 * 
 * @export
 * @interface SystemConfigStorageTemplateDto
 */
export interface SystemConfigStorageTemplateDto {
    /**
     * 
     * @type {string}
     * @memberof SystemConfigStorageTemplateDto
     */
    'template': string;
}
/**
 * 
 * @export
 * @interface SystemConfigTemplateStorageOptionDto
 */
export interface SystemConfigTemplateStorageOptionDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof SystemConfigTemplateStorageOptionDto
     */
    'yearOptions': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SystemConfigTemplateStorageOptionDto
     */
    'monthOptions': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SystemConfigTemplateStorageOptionDto
     */
    'dayOptions': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SystemConfigTemplateStorageOptionDto
     */
    'hourOptions': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SystemConfigTemplateStorageOptionDto
     */
    'minuteOptions': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SystemConfigTemplateStorageOptionDto
     */
    'secondOptions': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SystemConfigTemplateStorageOptionDto
     */
    'presetOptions': Array<string>;
}
/**
 * 
 * @export
 * @interface TagResponseDto
 */
export interface TagResponseDto {
    /**
     * 
     * @type {string}
     * @memberof TagResponseDto
     */
    'id': string;
    /**
     * 
     * @type {TagTypeEnum}
     * @memberof TagResponseDto
     */
    'type': TagTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TagResponseDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TagResponseDto
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof TagResponseDto
     */
    'renameTagId'?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const TagTypeEnum = {
    Object: 'OBJECT',
    Face: 'FACE',
    Custom: 'CUSTOM'
} as const;

export type TagTypeEnum = typeof TagTypeEnum[keyof typeof TagTypeEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const ThumbnailFormat = {
    Jpeg: 'JPEG',
    Webp: 'WEBP'
} as const;

export type ThumbnailFormat = typeof ThumbnailFormat[keyof typeof ThumbnailFormat];


/**
 * 
 * @export
 * @enum {string}
 */

export const TimeGroupEnum = {
    Day: 'day',
    Month: 'month'
} as const;

export type TimeGroupEnum = typeof TimeGroupEnum[keyof typeof TimeGroupEnum];


/**
 * 
 * @export
 * @interface UpdateAlbumDto
 */
export interface UpdateAlbumDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateAlbumDto
     */
    'albumName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAlbumDto
     */
    'albumThumbnailAssetId'?: string;
}
/**
 * 
 * @export
 * @interface UpdateAssetDto
 */
export interface UpdateAssetDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateAssetDto
     */
    'tagIds'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateAssetDto
     */
    'isFavorite'?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateTagDto
 */
export interface UpdateTagDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateTagDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTagDto
     */
    'renameTagId'?: string;
}
/**
 * 
 * @export
 * @interface UpdateUserDto
 */
export interface UpdateUserDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateUserDto
     */
    'isAdmin'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateUserDto
     */
    'shouldChangePassword'?: boolean;
}
/**
 * 
 * @export
 * @interface UpsertDeviceInfoDto
 */
export interface UpsertDeviceInfoDto {
    /**
     * 
     * @type {DeviceTypeEnum}
     * @memberof UpsertDeviceInfoDto
     */
    'deviceType': DeviceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof UpsertDeviceInfoDto
     */
    'deviceId': string;
    /**
     * 
     * @type {boolean}
     * @memberof UpsertDeviceInfoDto
     */
    'isAutoBackup'?: boolean;
}
/**
 * 
 * @export
 * @interface UsageByUserDto
 */
export interface UsageByUserDto {
    /**
     * 
     * @type {string}
     * @memberof UsageByUserDto
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof UsageByUserDto
     */
    'userFirstName': string;
    /**
     * 
     * @type {string}
     * @memberof UsageByUserDto
     */
    'userLastName': string;
    /**
     * 
     * @type {number}
     * @memberof UsageByUserDto
     */
    'photos': number;
    /**
     * 
     * @type {number}
     * @memberof UsageByUserDto
     */
    'videos': number;
    /**
     * 
     * @type {number}
     * @memberof UsageByUserDto
     */
    'usage': number;
}
/**
 * 
 * @export
 * @interface UserCountResponseDto
 */
export interface UserCountResponseDto {
    /**
     * 
     * @type {number}
     * @memberof UserCountResponseDto
     */
    'userCount': number;
}
/**
 * 
 * @export
 * @interface UserResponseDto
 */
export interface UserResponseDto {
    /**
     * 
     * @type {string}
     * @memberof UserResponseDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserResponseDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserResponseDto
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof UserResponseDto
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof UserResponseDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserResponseDto
     */
    'profileImagePath': string;
    /**
     * 
     * @type {boolean}
     * @memberof UserResponseDto
     */
    'shouldChangePassword': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserResponseDto
     */
    'isAdmin': boolean;
    /**
     * 
     * @type {string}
     * @memberof UserResponseDto
     */
    'deletedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponseDto
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponseDto
     */
    'oauthId': string;
}
/**
 * 
 * @export
 * @interface ValidateAccessTokenResponseDto
 */
export interface ValidateAccessTokenResponseDto {
    /**
     * 
     * @type {boolean}
     * @memberof ValidateAccessTokenResponseDto
     */
    'authStatus': boolean;
}

/**
 * APIKeyApi - axios parameter creator
 * @export
 */
export const APIKeyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {APIKeyCreateDto} aPIKeyCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKey: async (aPIKeyCreateDto: APIKeyCreateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'aPIKeyCreateDto' is not null or undefined
            assertParamExists('createKey', 'aPIKeyCreateDto', aPIKeyCreateDto)
            const localVarPath = `/api-key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aPIKeyCreateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKey: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteKey', 'id', id)
            const localVarPath = `/api-key/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKey: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getKey', 'id', id)
            const localVarPath = `/api-key/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKeys: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api-key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {APIKeyUpdateDto} aPIKeyUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKey: async (id: string, aPIKeyUpdateDto: APIKeyUpdateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateKey', 'id', id)
            // verify required parameter 'aPIKeyUpdateDto' is not null or undefined
            assertParamExists('updateKey', 'aPIKeyUpdateDto', aPIKeyUpdateDto)
            const localVarPath = `/api-key/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aPIKeyUpdateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * APIKeyApi - functional programming interface
 * @export
 */
export const APIKeyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = APIKeyApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {APIKeyCreateDto} aPIKeyCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createKey(aPIKeyCreateDto: APIKeyCreateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIKeyCreateResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createKey(aPIKeyCreateDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteKey(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteKey(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKey(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIKeyResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKey(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKeys(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<APIKeyResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKeys(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {APIKeyUpdateDto} aPIKeyUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateKey(id: string, aPIKeyUpdateDto: APIKeyUpdateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIKeyResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateKey(id, aPIKeyUpdateDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * APIKeyApi - factory interface
 * @export
 */
export const APIKeyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = APIKeyApiFp(configuration)
    return {
        /**
         * 
         * @param {APIKeyCreateDto} aPIKeyCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKey(aPIKeyCreateDto: APIKeyCreateDto, options?: any): AxiosPromise<APIKeyCreateResponseDto> {
            return localVarFp.createKey(aPIKeyCreateDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKey(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteKey(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKey(id: string, options?: any): AxiosPromise<APIKeyResponseDto> {
            return localVarFp.getKey(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKeys(options?: any): AxiosPromise<Array<APIKeyResponseDto>> {
            return localVarFp.getKeys(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {APIKeyUpdateDto} aPIKeyUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKey(id: string, aPIKeyUpdateDto: APIKeyUpdateDto, options?: any): AxiosPromise<APIKeyResponseDto> {
            return localVarFp.updateKey(id, aPIKeyUpdateDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * APIKeyApi - object-oriented interface
 * @export
 * @class APIKeyApi
 * @extends {BaseAPI}
 */
export class APIKeyApi extends BaseAPI {
    /**
     * 
     * @param {APIKeyCreateDto} aPIKeyCreateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeyApi
     */
    public createKey(aPIKeyCreateDto: APIKeyCreateDto, options?: AxiosRequestConfig) {
        return APIKeyApiFp(this.configuration).createKey(aPIKeyCreateDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeyApi
     */
    public deleteKey(id: string, options?: AxiosRequestConfig) {
        return APIKeyApiFp(this.configuration).deleteKey(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeyApi
     */
    public getKey(id: string, options?: AxiosRequestConfig) {
        return APIKeyApiFp(this.configuration).getKey(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeyApi
     */
    public getKeys(options?: AxiosRequestConfig) {
        return APIKeyApiFp(this.configuration).getKeys(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {APIKeyUpdateDto} aPIKeyUpdateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeyApi
     */
    public updateKey(id: string, aPIKeyUpdateDto: APIKeyUpdateDto, options?: AxiosRequestConfig) {
        return APIKeyApiFp(this.configuration).updateKey(id, aPIKeyUpdateDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AlbumApi - axios parameter creator
 * @export
 */
export const AlbumApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} albumId 
         * @param {AddAssetsDto} addAssetsDto 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAssetsToAlbum: async (albumId: string, addAssetsDto: AddAssetsDto, key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'albumId' is not null or undefined
            assertParamExists('addAssetsToAlbum', 'albumId', albumId)
            // verify required parameter 'addAssetsDto' is not null or undefined
            assertParamExists('addAssetsToAlbum', 'addAssetsDto', addAssetsDto)
            const localVarPath = `/album/{albumId}/assets`
                .replace(`{${"albumId"}}`, encodeURIComponent(String(albumId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addAssetsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} albumId 
         * @param {AddUsersDto} addUsersDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUsersToAlbum: async (albumId: string, addUsersDto: AddUsersDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'albumId' is not null or undefined
            assertParamExists('addUsersToAlbum', 'albumId', albumId)
            // verify required parameter 'addUsersDto' is not null or undefined
            assertParamExists('addUsersToAlbum', 'addUsersDto', addUsersDto)
            const localVarPath = `/album/{albumId}/users`
                .replace(`{${"albumId"}}`, encodeURIComponent(String(albumId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addUsersDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateAlbumDto} createAlbumDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlbum: async (createAlbumDto: CreateAlbumDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createAlbumDto' is not null or undefined
            assertParamExists('createAlbum', 'createAlbumDto', createAlbumDto)
            const localVarPath = `/album`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAlbumDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateAlbumShareLinkDto} createAlbumShareLinkDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlbumSharedLink: async (createAlbumShareLinkDto: CreateAlbumShareLinkDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createAlbumShareLinkDto' is not null or undefined
            assertParamExists('createAlbumSharedLink', 'createAlbumShareLinkDto', createAlbumShareLinkDto)
            const localVarPath = `/album/create-shared-link`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAlbumShareLinkDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} albumId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlbum: async (albumId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'albumId' is not null or undefined
            assertParamExists('deleteAlbum', 'albumId', albumId)
            const localVarPath = `/album/{albumId}`
                .replace(`{${"albumId"}}`, encodeURIComponent(String(albumId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} albumId 
         * @param {number} [skip] 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadArchive: async (albumId: string, skip?: number, key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'albumId' is not null or undefined
            assertParamExists('downloadArchive', 'albumId', albumId)
            const localVarPath = `/album/{albumId}/download`
                .replace(`{${"albumId"}}`, encodeURIComponent(String(albumId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlbumCountByUserId: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/album/count-by-user-id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} albumId 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlbumInfo: async (albumId: string, key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'albumId' is not null or undefined
            assertParamExists('getAlbumInfo', 'albumId', albumId)
            const localVarPath = `/album/{albumId}`
                .replace(`{${"albumId"}}`, encodeURIComponent(String(albumId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} [shared] 
         * @param {string} [assetId] Only returns albums that contain the asset Ignores the shared parameter undefined: get all albums
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAlbums: async (shared?: boolean, assetId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/album`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required

            if (shared !== undefined) {
                localVarQueryParameter['shared'] = shared;
            }

            if (assetId !== undefined) {
                localVarQueryParameter['assetId'] = assetId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} albumId 
         * @param {RemoveAssetsDto} removeAssetsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAssetFromAlbum: async (albumId: string, removeAssetsDto: RemoveAssetsDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'albumId' is not null or undefined
            assertParamExists('removeAssetFromAlbum', 'albumId', albumId)
            // verify required parameter 'removeAssetsDto' is not null or undefined
            assertParamExists('removeAssetFromAlbum', 'removeAssetsDto', removeAssetsDto)
            const localVarPath = `/album/{albumId}/assets`
                .replace(`{${"albumId"}}`, encodeURIComponent(String(albumId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(removeAssetsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} albumId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserFromAlbum: async (albumId: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'albumId' is not null or undefined
            assertParamExists('removeUserFromAlbum', 'albumId', albumId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('removeUserFromAlbum', 'userId', userId)
            const localVarPath = `/album/{albumId}/user/{userId}`
                .replace(`{${"albumId"}}`, encodeURIComponent(String(albumId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} albumId 
         * @param {UpdateAlbumDto} updateAlbumDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAlbumInfo: async (albumId: string, updateAlbumDto: UpdateAlbumDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'albumId' is not null or undefined
            assertParamExists('updateAlbumInfo', 'albumId', albumId)
            // verify required parameter 'updateAlbumDto' is not null or undefined
            assertParamExists('updateAlbumInfo', 'updateAlbumDto', updateAlbumDto)
            const localVarPath = `/album/{albumId}`
                .replace(`{${"albumId"}}`, encodeURIComponent(String(albumId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAlbumDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AlbumApi - functional programming interface
 * @export
 */
export const AlbumApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AlbumApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} albumId 
         * @param {AddAssetsDto} addAssetsDto 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addAssetsToAlbum(albumId: string, addAssetsDto: AddAssetsDto, key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddAssetsResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addAssetsToAlbum(albumId, addAssetsDto, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} albumId 
         * @param {AddUsersDto} addUsersDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUsersToAlbum(albumId: string, addUsersDto: AddUsersDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlbumResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addUsersToAlbum(albumId, addUsersDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CreateAlbumDto} createAlbumDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAlbum(createAlbumDto: CreateAlbumDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlbumResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAlbum(createAlbumDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CreateAlbumShareLinkDto} createAlbumShareLinkDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAlbumSharedLink(createAlbumShareLinkDto: CreateAlbumShareLinkDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SharedLinkResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAlbumSharedLink(createAlbumShareLinkDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} albumId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAlbum(albumId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAlbum(albumId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} albumId 
         * @param {number} [skip] 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadArchive(albumId: string, skip?: number, key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadArchive(albumId, skip, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAlbumCountByUserId(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlbumCountResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAlbumCountByUserId(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} albumId 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAlbumInfo(albumId: string, key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlbumResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAlbumInfo(albumId, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {boolean} [shared] 
         * @param {string} [assetId] Only returns albums that contain the asset Ignores the shared parameter undefined: get all albums
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllAlbums(shared?: boolean, assetId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AlbumResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllAlbums(shared, assetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} albumId 
         * @param {RemoveAssetsDto} removeAssetsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeAssetFromAlbum(albumId: string, removeAssetsDto: RemoveAssetsDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlbumResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeAssetFromAlbum(albumId, removeAssetsDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} albumId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeUserFromAlbum(albumId: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeUserFromAlbum(albumId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} albumId 
         * @param {UpdateAlbumDto} updateAlbumDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAlbumInfo(albumId: string, updateAlbumDto: UpdateAlbumDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlbumResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAlbumInfo(albumId, updateAlbumDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AlbumApi - factory interface
 * @export
 */
export const AlbumApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AlbumApiFp(configuration)
    return {
        /**
         * 
         * @param {string} albumId 
         * @param {AddAssetsDto} addAssetsDto 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAssetsToAlbum(albumId: string, addAssetsDto: AddAssetsDto, key?: string, options?: any): AxiosPromise<AddAssetsResponseDto> {
            return localVarFp.addAssetsToAlbum(albumId, addAssetsDto, key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} albumId 
         * @param {AddUsersDto} addUsersDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUsersToAlbum(albumId: string, addUsersDto: AddUsersDto, options?: any): AxiosPromise<AlbumResponseDto> {
            return localVarFp.addUsersToAlbum(albumId, addUsersDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateAlbumDto} createAlbumDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlbum(createAlbumDto: CreateAlbumDto, options?: any): AxiosPromise<AlbumResponseDto> {
            return localVarFp.createAlbum(createAlbumDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateAlbumShareLinkDto} createAlbumShareLinkDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlbumSharedLink(createAlbumShareLinkDto: CreateAlbumShareLinkDto, options?: any): AxiosPromise<SharedLinkResponseDto> {
            return localVarFp.createAlbumSharedLink(createAlbumShareLinkDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} albumId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlbum(albumId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAlbum(albumId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} albumId 
         * @param {number} [skip] 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadArchive(albumId: string, skip?: number, key?: string, options?: any): AxiosPromise<any> {
            return localVarFp.downloadArchive(albumId, skip, key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlbumCountByUserId(options?: any): AxiosPromise<AlbumCountResponseDto> {
            return localVarFp.getAlbumCountByUserId(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} albumId 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlbumInfo(albumId: string, key?: string, options?: any): AxiosPromise<AlbumResponseDto> {
            return localVarFp.getAlbumInfo(albumId, key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} [shared] 
         * @param {string} [assetId] Only returns albums that contain the asset Ignores the shared parameter undefined: get all albums
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAlbums(shared?: boolean, assetId?: string, options?: any): AxiosPromise<Array<AlbumResponseDto>> {
            return localVarFp.getAllAlbums(shared, assetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} albumId 
         * @param {RemoveAssetsDto} removeAssetsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAssetFromAlbum(albumId: string, removeAssetsDto: RemoveAssetsDto, options?: any): AxiosPromise<AlbumResponseDto> {
            return localVarFp.removeAssetFromAlbum(albumId, removeAssetsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} albumId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserFromAlbum(albumId: string, userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeUserFromAlbum(albumId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} albumId 
         * @param {UpdateAlbumDto} updateAlbumDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAlbumInfo(albumId: string, updateAlbumDto: UpdateAlbumDto, options?: any): AxiosPromise<AlbumResponseDto> {
            return localVarFp.updateAlbumInfo(albumId, updateAlbumDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AlbumApi - object-oriented interface
 * @export
 * @class AlbumApi
 * @extends {BaseAPI}
 */
export class AlbumApi extends BaseAPI {
    /**
     * 
     * @param {string} albumId 
     * @param {AddAssetsDto} addAssetsDto 
     * @param {string} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    public addAssetsToAlbum(albumId: string, addAssetsDto: AddAssetsDto, key?: string, options?: AxiosRequestConfig) {
        return AlbumApiFp(this.configuration).addAssetsToAlbum(albumId, addAssetsDto, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} albumId 
     * @param {AddUsersDto} addUsersDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    public addUsersToAlbum(albumId: string, addUsersDto: AddUsersDto, options?: AxiosRequestConfig) {
        return AlbumApiFp(this.configuration).addUsersToAlbum(albumId, addUsersDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateAlbumDto} createAlbumDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    public createAlbum(createAlbumDto: CreateAlbumDto, options?: AxiosRequestConfig) {
        return AlbumApiFp(this.configuration).createAlbum(createAlbumDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateAlbumShareLinkDto} createAlbumShareLinkDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    public createAlbumSharedLink(createAlbumShareLinkDto: CreateAlbumShareLinkDto, options?: AxiosRequestConfig) {
        return AlbumApiFp(this.configuration).createAlbumSharedLink(createAlbumShareLinkDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} albumId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    public deleteAlbum(albumId: string, options?: AxiosRequestConfig) {
        return AlbumApiFp(this.configuration).deleteAlbum(albumId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} albumId 
     * @param {number} [skip] 
     * @param {string} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    public downloadArchive(albumId: string, skip?: number, key?: string, options?: AxiosRequestConfig) {
        return AlbumApiFp(this.configuration).downloadArchive(albumId, skip, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    public getAlbumCountByUserId(options?: AxiosRequestConfig) {
        return AlbumApiFp(this.configuration).getAlbumCountByUserId(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} albumId 
     * @param {string} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    public getAlbumInfo(albumId: string, key?: string, options?: AxiosRequestConfig) {
        return AlbumApiFp(this.configuration).getAlbumInfo(albumId, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {boolean} [shared] 
     * @param {string} [assetId] Only returns albums that contain the asset Ignores the shared parameter undefined: get all albums
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    public getAllAlbums(shared?: boolean, assetId?: string, options?: AxiosRequestConfig) {
        return AlbumApiFp(this.configuration).getAllAlbums(shared, assetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} albumId 
     * @param {RemoveAssetsDto} removeAssetsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    public removeAssetFromAlbum(albumId: string, removeAssetsDto: RemoveAssetsDto, options?: AxiosRequestConfig) {
        return AlbumApiFp(this.configuration).removeAssetFromAlbum(albumId, removeAssetsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} albumId 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    public removeUserFromAlbum(albumId: string, userId: string, options?: AxiosRequestConfig) {
        return AlbumApiFp(this.configuration).removeUserFromAlbum(albumId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} albumId 
     * @param {UpdateAlbumDto} updateAlbumDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    public updateAlbumInfo(albumId: string, updateAlbumDto: UpdateAlbumDto, options?: AxiosRequestConfig) {
        return AlbumApiFp(this.configuration).updateAlbumInfo(albumId, updateAlbumDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AssetApi - axios parameter creator
 * @export
 */
export const AssetApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AddAssetsDto} addAssetsDto 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAssetsToSharedLink: async (addAssetsDto: AddAssetsDto, key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addAssetsDto' is not null or undefined
            assertParamExists('addAssetsToSharedLink', 'addAssetsDto', addAssetsDto)
            const localVarPath = `/asset/shared-link/add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addAssetsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check duplicated asset before uploading - for Web upload used
         * @param {CheckDuplicateAssetDto} checkDuplicateAssetDto 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkDuplicateAsset: async (checkDuplicateAssetDto: CheckDuplicateAssetDto, key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkDuplicateAssetDto' is not null or undefined
            assertParamExists('checkDuplicateAsset', 'checkDuplicateAssetDto', checkDuplicateAssetDto)
            const localVarPath = `/asset/check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkDuplicateAssetDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Checks if multiple assets exist on the server and returns all existing - used by background backup
         * @param {CheckExistingAssetsDto} checkExistingAssetsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkExistingAssets: async (checkExistingAssetsDto: CheckExistingAssetsDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkExistingAssetsDto' is not null or undefined
            assertParamExists('checkExistingAssets', 'checkExistingAssetsDto', checkExistingAssetsDto)
            const localVarPath = `/asset/exist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkExistingAssetsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateAssetsShareLinkDto} createAssetsShareLinkDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAssetsSharedLink: async (createAssetsShareLinkDto: CreateAssetsShareLinkDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createAssetsShareLinkDto' is not null or undefined
            assertParamExists('createAssetsSharedLink', 'createAssetsShareLinkDto', createAssetsShareLinkDto)
            const localVarPath = `/asset/shared-link`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAssetsShareLinkDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DeleteAssetDto} deleteAssetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAsset: async (deleteAssetDto: DeleteAssetDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteAssetDto' is not null or undefined
            assertParamExists('deleteAsset', 'deleteAssetDto', deleteAssetDto)
            const localVarPath = `/asset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteAssetDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} assetId 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile: async (assetId: string, key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('downloadFile', 'assetId', assetId)
            const localVarPath = `/asset/download/{assetId}`
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DownloadFilesDto} downloadFilesDto 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFiles: async (downloadFilesDto: DownloadFilesDto, key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'downloadFilesDto' is not null or undefined
            assertParamExists('downloadFiles', 'downloadFilesDto', downloadFilesDto)
            const localVarPath = `/asset/download-files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(downloadFilesDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Current this is not used in any UI element
         * @param {number} [skip] 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadLibrary: async (skip?: number, key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/asset/download-library`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all AssetEntity belong to the user
         * @param {boolean} [isFavorite] 
         * @param {number} [skip] 
         * @param {string} [ifNoneMatch] ETag of data already cached on the client
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAssets: async (isFavorite?: boolean, skip?: number, ifNoneMatch?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/asset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required

            if (isFavorite !== undefined) {
                localVarQueryParameter['isFavorite'] = isFavorite;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['if-none-match'] = String(ifNoneMatch);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single asset\'s information
         * @param {string} assetId 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetById: async (assetId: string, key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('getAssetById', 'assetId', assetId)
            const localVarPath = `/asset/assetById/{assetId}`
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GetAssetByTimeBucketDto} getAssetByTimeBucketDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetByTimeBucket: async (getAssetByTimeBucketDto: GetAssetByTimeBucketDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getAssetByTimeBucketDto' is not null or undefined
            assertParamExists('getAssetByTimeBucket', 'getAssetByTimeBucketDto', getAssetByTimeBucketDto)
            const localVarPath = `/asset/time-bucket`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getAssetByTimeBucketDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GetAssetCountByTimeBucketDto} getAssetCountByTimeBucketDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetCountByTimeBucket: async (getAssetCountByTimeBucketDto: GetAssetCountByTimeBucketDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getAssetCountByTimeBucketDto' is not null or undefined
            assertParamExists('getAssetCountByTimeBucket', 'getAssetCountByTimeBucketDto', getAssetCountByTimeBucketDto)
            const localVarPath = `/asset/count-by-time-bucket`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getAssetCountByTimeBucketDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetCountByUserId: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/asset/count-by-user-id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetSearchTerms: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/asset/search-terms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} assetId 
         * @param {ThumbnailFormat} [format] 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetThumbnail: async (assetId: string, format?: ThumbnailFormat, key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('getAssetThumbnail', 'assetId', assetId)
            const localVarPath = `/asset/thumbnail/{assetId}`
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCuratedLocations: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/asset/curated-locations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCuratedObjects: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/asset/curated-objects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all asset of a device that are in the database, ID only.
         * @param {string} deviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAssetsByDeviceId: async (deviceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('getUserAssetsByDeviceId', 'deviceId', deviceId)
            const localVarPath = `/asset/{deviceId}`
                .replace(`{${"deviceId"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RemoveAssetsDto} removeAssetsDto 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAssetsFromSharedLink: async (removeAssetsDto: RemoveAssetsDto, key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'removeAssetsDto' is not null or undefined
            assertParamExists('removeAssetsFromSharedLink', 'removeAssetsDto', removeAssetsDto)
            const localVarPath = `/asset/shared-link/remove`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(removeAssetsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SearchAssetDto} searchAssetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAsset: async (searchAssetDto: SearchAssetDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchAssetDto' is not null or undefined
            assertParamExists('searchAsset', 'searchAssetDto', searchAssetDto)
            const localVarPath = `/asset/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchAssetDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} assetId 
         * @param {boolean} [isThumb] 
         * @param {boolean} [isWeb] 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serveFile: async (assetId: string, isThumb?: boolean, isWeb?: boolean, key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('serveFile', 'assetId', assetId)
            const localVarPath = `/asset/file/{assetId}`
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required

            if (isThumb !== undefined) {
                localVarQueryParameter['isThumb'] = isThumb;
            }

            if (isWeb !== undefined) {
                localVarQueryParameter['isWeb'] = isWeb;
            }

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an asset
         * @param {string} assetId 
         * @param {UpdateAssetDto} updateAssetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAsset: async (assetId: string, updateAssetDto: UpdateAssetDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('updateAsset', 'assetId', assetId)
            // verify required parameter 'updateAssetDto' is not null or undefined
            assertParamExists('updateAsset', 'updateAssetDto', updateAssetDto)
            const localVarPath = `/asset/{assetId}`
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAssetDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AssetTypeEnum} assetType 
         * @param {any} assetData 
         * @param {string} deviceAssetId 
         * @param {string} deviceId 
         * @param {string} fileCreatedAt 
         * @param {string} fileModifiedAt 
         * @param {boolean} isFavorite 
         * @param {string} fileExtension 
         * @param {string} [key] 
         * @param {any} [livePhotoData] 
         * @param {boolean} [isVisible] 
         * @param {string} [duration] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile: async (assetType: AssetTypeEnum, assetData: any, deviceAssetId: string, deviceId: string, fileCreatedAt: string, fileModifiedAt: string, isFavorite: boolean, fileExtension: string, key?: string, livePhotoData?: any, isVisible?: boolean, duration?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetType' is not null or undefined
            assertParamExists('uploadFile', 'assetType', assetType)
            // verify required parameter 'assetData' is not null or undefined
            assertParamExists('uploadFile', 'assetData', assetData)
            // verify required parameter 'deviceAssetId' is not null or undefined
            assertParamExists('uploadFile', 'deviceAssetId', deviceAssetId)
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('uploadFile', 'deviceId', deviceId)
            // verify required parameter 'fileCreatedAt' is not null or undefined
            assertParamExists('uploadFile', 'fileCreatedAt', fileCreatedAt)
            // verify required parameter 'fileModifiedAt' is not null or undefined
            assertParamExists('uploadFile', 'fileModifiedAt', fileModifiedAt)
            // verify required parameter 'isFavorite' is not null or undefined
            assertParamExists('uploadFile', 'isFavorite', isFavorite)
            // verify required parameter 'fileExtension' is not null or undefined
            assertParamExists('uploadFile', 'fileExtension', fileExtension)
            const localVarPath = `/asset/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


            if (assetType !== undefined) { 
                localVarFormParams.append('assetType', new Blob([JSON.stringify(assetType)], { type: "application/json", }));
            }
    
            if (assetData !== undefined) { 
                localVarFormParams.append('assetData', assetData as any);
            }
    
            if (livePhotoData !== undefined) { 
                localVarFormParams.append('livePhotoData', livePhotoData as any);
            }
    
            if (deviceAssetId !== undefined) { 
                localVarFormParams.append('deviceAssetId', deviceAssetId as any);
            }
    
            if (deviceId !== undefined) { 
                localVarFormParams.append('deviceId', deviceId as any);
            }
    
            if (fileCreatedAt !== undefined) { 
                localVarFormParams.append('fileCreatedAt', fileCreatedAt as any);
            }
    
            if (fileModifiedAt !== undefined) { 
                localVarFormParams.append('fileModifiedAt', fileModifiedAt as any);
            }
    
            if (isFavorite !== undefined) { 
                localVarFormParams.append('isFavorite', isFavorite as any);
            }
    
            if (isVisible !== undefined) { 
                localVarFormParams.append('isVisible', isVisible as any);
            }
    
            if (fileExtension !== undefined) { 
                localVarFormParams.append('fileExtension', fileExtension as any);
            }
    
            if (duration !== undefined) { 
                localVarFormParams.append('duration', duration as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AssetApi - functional programming interface
 * @export
 */
export const AssetApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AssetApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AddAssetsDto} addAssetsDto 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addAssetsToSharedLink(addAssetsDto: AddAssetsDto, key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SharedLinkResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addAssetsToSharedLink(addAssetsDto, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Check duplicated asset before uploading - for Web upload used
         * @param {CheckDuplicateAssetDto} checkDuplicateAssetDto 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkDuplicateAsset(checkDuplicateAssetDto: CheckDuplicateAssetDto, key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckDuplicateAssetResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkDuplicateAsset(checkDuplicateAssetDto, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Checks if multiple assets exist on the server and returns all existing - used by background backup
         * @param {CheckExistingAssetsDto} checkExistingAssetsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkExistingAssets(checkExistingAssetsDto: CheckExistingAssetsDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckExistingAssetsResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkExistingAssets(checkExistingAssetsDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CreateAssetsShareLinkDto} createAssetsShareLinkDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAssetsSharedLink(createAssetsShareLinkDto: CreateAssetsShareLinkDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SharedLinkResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAssetsSharedLink(createAssetsShareLinkDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {DeleteAssetDto} deleteAssetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAsset(deleteAssetDto: DeleteAssetDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeleteAssetResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAsset(deleteAssetDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} assetId 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadFile(assetId: string, key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadFile(assetId, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {DownloadFilesDto} downloadFilesDto 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadFiles(downloadFilesDto: DownloadFilesDto, key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadFiles(downloadFilesDto, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Current this is not used in any UI element
         * @param {number} [skip] 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadLibrary(skip?: number, key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadLibrary(skip, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all AssetEntity belong to the user
         * @param {boolean} [isFavorite] 
         * @param {number} [skip] 
         * @param {string} [ifNoneMatch] ETag of data already cached on the client
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllAssets(isFavorite?: boolean, skip?: number, ifNoneMatch?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AssetResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllAssets(isFavorite, skip, ifNoneMatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single asset\'s information
         * @param {string} assetId 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssetById(assetId: string, key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssetById(assetId, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {GetAssetByTimeBucketDto} getAssetByTimeBucketDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssetByTimeBucket(getAssetByTimeBucketDto: GetAssetByTimeBucketDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AssetResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssetByTimeBucket(getAssetByTimeBucketDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {GetAssetCountByTimeBucketDto} getAssetCountByTimeBucketDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssetCountByTimeBucket(getAssetCountByTimeBucketDto: GetAssetCountByTimeBucketDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetCountByTimeBucketResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssetCountByTimeBucket(getAssetCountByTimeBucketDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssetCountByUserId(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetCountByUserIdResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssetCountByUserId(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssetSearchTerms(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssetSearchTerms(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} assetId 
         * @param {ThumbnailFormat} [format] 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssetThumbnail(assetId: string, format?: ThumbnailFormat, key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssetThumbnail(assetId, format, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCuratedLocations(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CuratedLocationsResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCuratedLocations(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCuratedObjects(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CuratedObjectsResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCuratedObjects(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all asset of a device that are in the database, ID only.
         * @param {string} deviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserAssetsByDeviceId(deviceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserAssetsByDeviceId(deviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {RemoveAssetsDto} removeAssetsDto 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeAssetsFromSharedLink(removeAssetsDto: RemoveAssetsDto, key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SharedLinkResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeAssetsFromSharedLink(removeAssetsDto, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SearchAssetDto} searchAssetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchAsset(searchAssetDto: SearchAssetDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AssetResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchAsset(searchAssetDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} assetId 
         * @param {boolean} [isThumb] 
         * @param {boolean} [isWeb] 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serveFile(assetId: string, isThumb?: boolean, isWeb?: boolean, key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serveFile(assetId, isThumb, isWeb, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an asset
         * @param {string} assetId 
         * @param {UpdateAssetDto} updateAssetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAsset(assetId: string, updateAssetDto: UpdateAssetDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAsset(assetId, updateAssetDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {AssetTypeEnum} assetType 
         * @param {any} assetData 
         * @param {string} deviceAssetId 
         * @param {string} deviceId 
         * @param {string} fileCreatedAt 
         * @param {string} fileModifiedAt 
         * @param {boolean} isFavorite 
         * @param {string} fileExtension 
         * @param {string} [key] 
         * @param {any} [livePhotoData] 
         * @param {boolean} [isVisible] 
         * @param {string} [duration] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFile(assetType: AssetTypeEnum, assetData: any, deviceAssetId: string, deviceId: string, fileCreatedAt: string, fileModifiedAt: string, isFavorite: boolean, fileExtension: string, key?: string, livePhotoData?: any, isVisible?: boolean, duration?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetFileUploadResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFile(assetType, assetData, deviceAssetId, deviceId, fileCreatedAt, fileModifiedAt, isFavorite, fileExtension, key, livePhotoData, isVisible, duration, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AssetApi - factory interface
 * @export
 */
export const AssetApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AssetApiFp(configuration)
    return {
        /**
         * 
         * @param {AddAssetsDto} addAssetsDto 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAssetsToSharedLink(addAssetsDto: AddAssetsDto, key?: string, options?: any): AxiosPromise<SharedLinkResponseDto> {
            return localVarFp.addAssetsToSharedLink(addAssetsDto, key, options).then((request) => request(axios, basePath));
        },
        /**
         * Check duplicated asset before uploading - for Web upload used
         * @param {CheckDuplicateAssetDto} checkDuplicateAssetDto 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkDuplicateAsset(checkDuplicateAssetDto: CheckDuplicateAssetDto, key?: string, options?: any): AxiosPromise<CheckDuplicateAssetResponseDto> {
            return localVarFp.checkDuplicateAsset(checkDuplicateAssetDto, key, options).then((request) => request(axios, basePath));
        },
        /**
         * Checks if multiple assets exist on the server and returns all existing - used by background backup
         * @param {CheckExistingAssetsDto} checkExistingAssetsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkExistingAssets(checkExistingAssetsDto: CheckExistingAssetsDto, options?: any): AxiosPromise<CheckExistingAssetsResponseDto> {
            return localVarFp.checkExistingAssets(checkExistingAssetsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateAssetsShareLinkDto} createAssetsShareLinkDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAssetsSharedLink(createAssetsShareLinkDto: CreateAssetsShareLinkDto, options?: any): AxiosPromise<SharedLinkResponseDto> {
            return localVarFp.createAssetsSharedLink(createAssetsShareLinkDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DeleteAssetDto} deleteAssetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAsset(deleteAssetDto: DeleteAssetDto, options?: any): AxiosPromise<Array<DeleteAssetResponseDto>> {
            return localVarFp.deleteAsset(deleteAssetDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} assetId 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile(assetId: string, key?: string, options?: any): AxiosPromise<any> {
            return localVarFp.downloadFile(assetId, key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DownloadFilesDto} downloadFilesDto 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFiles(downloadFilesDto: DownloadFilesDto, key?: string, options?: any): AxiosPromise<any> {
            return localVarFp.downloadFiles(downloadFilesDto, key, options).then((request) => request(axios, basePath));
        },
        /**
         * Current this is not used in any UI element
         * @param {number} [skip] 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadLibrary(skip?: number, key?: string, options?: any): AxiosPromise<any> {
            return localVarFp.downloadLibrary(skip, key, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all AssetEntity belong to the user
         * @param {boolean} [isFavorite] 
         * @param {number} [skip] 
         * @param {string} [ifNoneMatch] ETag of data already cached on the client
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAssets(isFavorite?: boolean, skip?: number, ifNoneMatch?: string, options?: any): AxiosPromise<Array<AssetResponseDto>> {
            return localVarFp.getAllAssets(isFavorite, skip, ifNoneMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single asset\'s information
         * @param {string} assetId 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetById(assetId: string, key?: string, options?: any): AxiosPromise<AssetResponseDto> {
            return localVarFp.getAssetById(assetId, key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GetAssetByTimeBucketDto} getAssetByTimeBucketDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetByTimeBucket(getAssetByTimeBucketDto: GetAssetByTimeBucketDto, options?: any): AxiosPromise<Array<AssetResponseDto>> {
            return localVarFp.getAssetByTimeBucket(getAssetByTimeBucketDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GetAssetCountByTimeBucketDto} getAssetCountByTimeBucketDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetCountByTimeBucket(getAssetCountByTimeBucketDto: GetAssetCountByTimeBucketDto, options?: any): AxiosPromise<AssetCountByTimeBucketResponseDto> {
            return localVarFp.getAssetCountByTimeBucket(getAssetCountByTimeBucketDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetCountByUserId(options?: any): AxiosPromise<AssetCountByUserIdResponseDto> {
            return localVarFp.getAssetCountByUserId(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetSearchTerms(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getAssetSearchTerms(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} assetId 
         * @param {ThumbnailFormat} [format] 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetThumbnail(assetId: string, format?: ThumbnailFormat, key?: string, options?: any): AxiosPromise<any> {
            return localVarFp.getAssetThumbnail(assetId, format, key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCuratedLocations(options?: any): AxiosPromise<Array<CuratedLocationsResponseDto>> {
            return localVarFp.getCuratedLocations(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCuratedObjects(options?: any): AxiosPromise<Array<CuratedObjectsResponseDto>> {
            return localVarFp.getCuratedObjects(options).then((request) => request(axios, basePath));
        },
        /**
         * Get all asset of a device that are in the database, ID only.
         * @param {string} deviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAssetsByDeviceId(deviceId: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getUserAssetsByDeviceId(deviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RemoveAssetsDto} removeAssetsDto 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAssetsFromSharedLink(removeAssetsDto: RemoveAssetsDto, key?: string, options?: any): AxiosPromise<SharedLinkResponseDto> {
            return localVarFp.removeAssetsFromSharedLink(removeAssetsDto, key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SearchAssetDto} searchAssetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAsset(searchAssetDto: SearchAssetDto, options?: any): AxiosPromise<Array<AssetResponseDto>> {
            return localVarFp.searchAsset(searchAssetDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} assetId 
         * @param {boolean} [isThumb] 
         * @param {boolean} [isWeb] 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serveFile(assetId: string, isThumb?: boolean, isWeb?: boolean, key?: string, options?: any): AxiosPromise<any> {
            return localVarFp.serveFile(assetId, isThumb, isWeb, key, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an asset
         * @param {string} assetId 
         * @param {UpdateAssetDto} updateAssetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAsset(assetId: string, updateAssetDto: UpdateAssetDto, options?: any): AxiosPromise<AssetResponseDto> {
            return localVarFp.updateAsset(assetId, updateAssetDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AssetTypeEnum} assetType 
         * @param {any} assetData 
         * @param {string} deviceAssetId 
         * @param {string} deviceId 
         * @param {string} fileCreatedAt 
         * @param {string} fileModifiedAt 
         * @param {boolean} isFavorite 
         * @param {string} fileExtension 
         * @param {string} [key] 
         * @param {any} [livePhotoData] 
         * @param {boolean} [isVisible] 
         * @param {string} [duration] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile(assetType: AssetTypeEnum, assetData: any, deviceAssetId: string, deviceId: string, fileCreatedAt: string, fileModifiedAt: string, isFavorite: boolean, fileExtension: string, key?: string, livePhotoData?: any, isVisible?: boolean, duration?: string, options?: any): AxiosPromise<AssetFileUploadResponseDto> {
            return localVarFp.uploadFile(assetType, assetData, deviceAssetId, deviceId, fileCreatedAt, fileModifiedAt, isFavorite, fileExtension, key, livePhotoData, isVisible, duration, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AssetApi - object-oriented interface
 * @export
 * @class AssetApi
 * @extends {BaseAPI}
 */
export class AssetApi extends BaseAPI {
    /**
     * 
     * @param {AddAssetsDto} addAssetsDto 
     * @param {string} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public addAssetsToSharedLink(addAssetsDto: AddAssetsDto, key?: string, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).addAssetsToSharedLink(addAssetsDto, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check duplicated asset before uploading - for Web upload used
     * @param {CheckDuplicateAssetDto} checkDuplicateAssetDto 
     * @param {string} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public checkDuplicateAsset(checkDuplicateAssetDto: CheckDuplicateAssetDto, key?: string, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).checkDuplicateAsset(checkDuplicateAssetDto, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Checks if multiple assets exist on the server and returns all existing - used by background backup
     * @param {CheckExistingAssetsDto} checkExistingAssetsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public checkExistingAssets(checkExistingAssetsDto: CheckExistingAssetsDto, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).checkExistingAssets(checkExistingAssetsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateAssetsShareLinkDto} createAssetsShareLinkDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public createAssetsSharedLink(createAssetsShareLinkDto: CreateAssetsShareLinkDto, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).createAssetsSharedLink(createAssetsShareLinkDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DeleteAssetDto} deleteAssetDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public deleteAsset(deleteAssetDto: DeleteAssetDto, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).deleteAsset(deleteAssetDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} assetId 
     * @param {string} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public downloadFile(assetId: string, key?: string, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).downloadFile(assetId, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DownloadFilesDto} downloadFilesDto 
     * @param {string} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public downloadFiles(downloadFilesDto: DownloadFilesDto, key?: string, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).downloadFiles(downloadFilesDto, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Current this is not used in any UI element
     * @param {number} [skip] 
     * @param {string} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public downloadLibrary(skip?: number, key?: string, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).downloadLibrary(skip, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all AssetEntity belong to the user
     * @param {boolean} [isFavorite] 
     * @param {number} [skip] 
     * @param {string} [ifNoneMatch] ETag of data already cached on the client
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getAllAssets(isFavorite?: boolean, skip?: number, ifNoneMatch?: string, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getAllAssets(isFavorite, skip, ifNoneMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single asset\'s information
     * @param {string} assetId 
     * @param {string} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getAssetById(assetId: string, key?: string, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getAssetById(assetId, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GetAssetByTimeBucketDto} getAssetByTimeBucketDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getAssetByTimeBucket(getAssetByTimeBucketDto: GetAssetByTimeBucketDto, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getAssetByTimeBucket(getAssetByTimeBucketDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GetAssetCountByTimeBucketDto} getAssetCountByTimeBucketDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getAssetCountByTimeBucket(getAssetCountByTimeBucketDto: GetAssetCountByTimeBucketDto, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getAssetCountByTimeBucket(getAssetCountByTimeBucketDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getAssetCountByUserId(options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getAssetCountByUserId(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getAssetSearchTerms(options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getAssetSearchTerms(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} assetId 
     * @param {ThumbnailFormat} [format] 
     * @param {string} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getAssetThumbnail(assetId: string, format?: ThumbnailFormat, key?: string, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getAssetThumbnail(assetId, format, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getCuratedLocations(options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getCuratedLocations(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getCuratedObjects(options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getCuratedObjects(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all asset of a device that are in the database, ID only.
     * @param {string} deviceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getUserAssetsByDeviceId(deviceId: string, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getUserAssetsByDeviceId(deviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RemoveAssetsDto} removeAssetsDto 
     * @param {string} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public removeAssetsFromSharedLink(removeAssetsDto: RemoveAssetsDto, key?: string, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).removeAssetsFromSharedLink(removeAssetsDto, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SearchAssetDto} searchAssetDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public searchAsset(searchAssetDto: SearchAssetDto, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).searchAsset(searchAssetDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} assetId 
     * @param {boolean} [isThumb] 
     * @param {boolean} [isWeb] 
     * @param {string} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public serveFile(assetId: string, isThumb?: boolean, isWeb?: boolean, key?: string, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).serveFile(assetId, isThumb, isWeb, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an asset
     * @param {string} assetId 
     * @param {UpdateAssetDto} updateAssetDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public updateAsset(assetId: string, updateAssetDto: UpdateAssetDto, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).updateAsset(assetId, updateAssetDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AssetTypeEnum} assetType 
     * @param {any} assetData 
     * @param {string} deviceAssetId 
     * @param {string} deviceId 
     * @param {string} fileCreatedAt 
     * @param {string} fileModifiedAt 
     * @param {boolean} isFavorite 
     * @param {string} fileExtension 
     * @param {string} [key] 
     * @param {any} [livePhotoData] 
     * @param {boolean} [isVisible] 
     * @param {string} [duration] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public uploadFile(assetType: AssetTypeEnum, assetData: any, deviceAssetId: string, deviceId: string, fileCreatedAt: string, fileModifiedAt: string, isFavorite: boolean, fileExtension: string, key?: string, livePhotoData?: any, isVisible?: boolean, duration?: string, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).uploadFile(assetType, assetData, deviceAssetId, deviceId, fileCreatedAt, fileModifiedAt, isFavorite, fileExtension, key, livePhotoData, isVisible, duration, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {SignUpDto} signUpDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminSignUp: async (signUpDto: SignUpDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signUpDto' is not null or undefined
            assertParamExists('adminSignUp', 'signUpDto', signUpDto)
            const localVarPath = `/auth/admin-sign-up`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signUpDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ChangePasswordDto} changePasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword: async (changePasswordDto: ChangePasswordDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'changePasswordDto' is not null or undefined
            assertParamExists('changePassword', 'changePasswordDto', changePasswordDto)
            const localVarPath = `/auth/change-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changePasswordDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {LoginCredentialDto} loginCredentialDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginCredentialDto: LoginCredentialDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginCredentialDto' is not null or undefined
            assertParamExists('login', 'loginCredentialDto', loginCredentialDto)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginCredentialDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateAccessToken: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/validateToken`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {SignUpDto} signUpDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminSignUp(signUpDto: SignUpDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminSignupResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminSignUp(signUpDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ChangePasswordDto} changePasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changePassword(changePasswordDto: ChangePasswordDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changePassword(changePasswordDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {LoginCredentialDto} loginCredentialDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginCredentialDto: LoginCredentialDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginCredentialDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogoutResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateAccessToken(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidateAccessTokenResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateAccessToken(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * 
         * @param {SignUpDto} signUpDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminSignUp(signUpDto: SignUpDto, options?: any): AxiosPromise<AdminSignupResponseDto> {
            return localVarFp.adminSignUp(signUpDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ChangePasswordDto} changePasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(changePasswordDto: ChangePasswordDto, options?: any): AxiosPromise<UserResponseDto> {
            return localVarFp.changePassword(changePasswordDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {LoginCredentialDto} loginCredentialDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginCredentialDto: LoginCredentialDto, options?: any): AxiosPromise<LoginResponseDto> {
            return localVarFp.login(loginCredentialDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: any): AxiosPromise<LogoutResponseDto> {
            return localVarFp.logout(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateAccessToken(options?: any): AxiosPromise<ValidateAccessTokenResponseDto> {
            return localVarFp.validateAccessToken(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * 
     * @param {SignUpDto} signUpDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public adminSignUp(signUpDto: SignUpDto, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).adminSignUp(signUpDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ChangePasswordDto} changePasswordDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public changePassword(changePasswordDto: ChangePasswordDto, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).changePassword(changePasswordDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LoginCredentialDto} loginCredentialDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public login(loginCredentialDto: LoginCredentialDto, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).login(loginCredentialDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public logout(options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).logout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public validateAccessToken(options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).validateAccessToken(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DeviceInfoApi - axios parameter creator
 * @export
 */
export const DeviceInfoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {UpsertDeviceInfoDto} upsertDeviceInfoDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertDeviceInfo: async (upsertDeviceInfoDto: UpsertDeviceInfoDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'upsertDeviceInfoDto' is not null or undefined
            assertParamExists('upsertDeviceInfo', 'upsertDeviceInfoDto', upsertDeviceInfoDto)
            const localVarPath = `/device-info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(upsertDeviceInfoDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeviceInfoApi - functional programming interface
 * @export
 */
export const DeviceInfoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeviceInfoApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {UpsertDeviceInfoDto} upsertDeviceInfoDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upsertDeviceInfo(upsertDeviceInfoDto: UpsertDeviceInfoDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceInfoResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.upsertDeviceInfo(upsertDeviceInfoDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DeviceInfoApi - factory interface
 * @export
 */
export const DeviceInfoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeviceInfoApiFp(configuration)
    return {
        /**
         * 
         * @param {UpsertDeviceInfoDto} upsertDeviceInfoDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertDeviceInfo(upsertDeviceInfoDto: UpsertDeviceInfoDto, options?: any): AxiosPromise<DeviceInfoResponseDto> {
            return localVarFp.upsertDeviceInfo(upsertDeviceInfoDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeviceInfoApi - object-oriented interface
 * @export
 * @class DeviceInfoApi
 * @extends {BaseAPI}
 */
export class DeviceInfoApi extends BaseAPI {
    /**
     * 
     * @param {UpsertDeviceInfoDto} upsertDeviceInfoDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceInfoApi
     */
    public upsertDeviceInfo(upsertDeviceInfoDto: UpsertDeviceInfoDto, options?: AxiosRequestConfig) {
        return DeviceInfoApiFp(this.configuration).upsertDeviceInfo(upsertDeviceInfoDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * JobApi - axios parameter creator
 * @export
 */
export const JobApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllJobsStatus: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/jobs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {JobName} jobId 
         * @param {JobCommandDto} jobCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendJobCommand: async (jobId: JobName, jobCommandDto: JobCommandDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('sendJobCommand', 'jobId', jobId)
            // verify required parameter 'jobCommandDto' is not null or undefined
            assertParamExists('sendJobCommand', 'jobCommandDto', jobCommandDto)
            const localVarPath = `/jobs/{jobId}`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jobCommandDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobApi - functional programming interface
 * @export
 */
export const JobApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JobApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllJobsStatus(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AllJobStatusResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllJobsStatus(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {JobName} jobId 
         * @param {JobCommandDto} jobCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendJobCommand(jobId: JobName, jobCommandDto: JobCommandDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendJobCommand(jobId, jobCommandDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * JobApi - factory interface
 * @export
 */
export const JobApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JobApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllJobsStatus(options?: any): AxiosPromise<AllJobStatusResponseDto> {
            return localVarFp.getAllJobsStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {JobName} jobId 
         * @param {JobCommandDto} jobCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendJobCommand(jobId: JobName, jobCommandDto: JobCommandDto, options?: any): AxiosPromise<void> {
            return localVarFp.sendJobCommand(jobId, jobCommandDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JobApi - object-oriented interface
 * @export
 * @class JobApi
 * @extends {BaseAPI}
 */
export class JobApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public getAllJobsStatus(options?: AxiosRequestConfig) {
        return JobApiFp(this.configuration).getAllJobsStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {JobName} jobId 
     * @param {JobCommandDto} jobCommandDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public sendJobCommand(jobId: JobName, jobCommandDto: JobCommandDto, options?: AxiosRequestConfig) {
        return JobApiFp(this.configuration).sendJobCommand(jobId, jobCommandDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OAuthApi - axios parameter creator
 * @export
 */
export const OAuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {OAuthCallbackDto} oAuthCallbackDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callback: async (oAuthCallbackDto: OAuthCallbackDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'oAuthCallbackDto' is not null or undefined
            assertParamExists('callback', 'oAuthCallbackDto', oAuthCallbackDto)
            const localVarPath = `/oauth/callback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(oAuthCallbackDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OAuthConfigDto} oAuthConfigDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateConfig: async (oAuthConfigDto: OAuthConfigDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'oAuthConfigDto' is not null or undefined
            assertParamExists('generateConfig', 'oAuthConfigDto', oAuthConfigDto)
            const localVarPath = `/oauth/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(oAuthConfigDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OAuthCallbackDto} oAuthCallbackDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        link: async (oAuthCallbackDto: OAuthCallbackDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'oAuthCallbackDto' is not null or undefined
            assertParamExists('link', 'oAuthCallbackDto', oAuthCallbackDto)
            const localVarPath = `/oauth/link`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(oAuthCallbackDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mobileRedirect: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/oauth/mobile-redirect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlink: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/oauth/unlink`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OAuthApi - functional programming interface
 * @export
 */
export const OAuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OAuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {OAuthCallbackDto} oAuthCallbackDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callback(oAuthCallbackDto: OAuthCallbackDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callback(oAuthCallbackDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {OAuthConfigDto} oAuthConfigDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateConfig(oAuthConfigDto: OAuthConfigDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OAuthConfigResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateConfig(oAuthConfigDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {OAuthCallbackDto} oAuthCallbackDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async link(oAuthCallbackDto: OAuthCallbackDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.link(oAuthCallbackDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mobileRedirect(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mobileRedirect(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlink(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unlink(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OAuthApi - factory interface
 * @export
 */
export const OAuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OAuthApiFp(configuration)
    return {
        /**
         * 
         * @param {OAuthCallbackDto} oAuthCallbackDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callback(oAuthCallbackDto: OAuthCallbackDto, options?: any): AxiosPromise<LoginResponseDto> {
            return localVarFp.callback(oAuthCallbackDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {OAuthConfigDto} oAuthConfigDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateConfig(oAuthConfigDto: OAuthConfigDto, options?: any): AxiosPromise<OAuthConfigResponseDto> {
            return localVarFp.generateConfig(oAuthConfigDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {OAuthCallbackDto} oAuthCallbackDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        link(oAuthCallbackDto: OAuthCallbackDto, options?: any): AxiosPromise<UserResponseDto> {
            return localVarFp.link(oAuthCallbackDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mobileRedirect(options?: any): AxiosPromise<void> {
            return localVarFp.mobileRedirect(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlink(options?: any): AxiosPromise<UserResponseDto> {
            return localVarFp.unlink(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OAuthApi - object-oriented interface
 * @export
 * @class OAuthApi
 * @extends {BaseAPI}
 */
export class OAuthApi extends BaseAPI {
    /**
     * 
     * @param {OAuthCallbackDto} oAuthCallbackDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public callback(oAuthCallbackDto: OAuthCallbackDto, options?: AxiosRequestConfig) {
        return OAuthApiFp(this.configuration).callback(oAuthCallbackDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {OAuthConfigDto} oAuthConfigDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public generateConfig(oAuthConfigDto: OAuthConfigDto, options?: AxiosRequestConfig) {
        return OAuthApiFp(this.configuration).generateConfig(oAuthConfigDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {OAuthCallbackDto} oAuthCallbackDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public link(oAuthCallbackDto: OAuthCallbackDto, options?: AxiosRequestConfig) {
        return OAuthApiFp(this.configuration).link(oAuthCallbackDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public mobileRedirect(options?: AxiosRequestConfig) {
        return OAuthApiFp(this.configuration).mobileRedirect(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public unlink(options?: AxiosRequestConfig) {
        return OAuthApiFp(this.configuration).unlink(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SearchApi - axios parameter creator
 * @export
 */
export const SearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExploreData: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/search/explore`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSearchConfig: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/search/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [q] 
         * @param {string} [query] 
         * @param {boolean} [clip] 
         * @param {'IMAGE' | 'VIDEO' | 'AUDIO' | 'OTHER'} [type] 
         * @param {boolean} [isFavorite] 
         * @param {string} [exifInfoCity] 
         * @param {string} [exifInfoState] 
         * @param {string} [exifInfoCountry] 
         * @param {string} [exifInfoMake] 
         * @param {string} [exifInfoModel] 
         * @param {Array<string>} [smartInfoObjects] 
         * @param {Array<string>} [smartInfoTags] 
         * @param {boolean} [recent] 
         * @param {boolean} [motion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: async (q?: string, query?: string, clip?: boolean, type?: 'IMAGE' | 'VIDEO' | 'AUDIO' | 'OTHER', isFavorite?: boolean, exifInfoCity?: string, exifInfoState?: string, exifInfoCountry?: string, exifInfoMake?: string, exifInfoModel?: string, smartInfoObjects?: Array<string>, smartInfoTags?: Array<string>, recent?: boolean, motion?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (clip !== undefined) {
                localVarQueryParameter['clip'] = clip;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (isFavorite !== undefined) {
                localVarQueryParameter['isFavorite'] = isFavorite;
            }

            if (exifInfoCity !== undefined) {
                localVarQueryParameter['exifInfo.city'] = exifInfoCity;
            }

            if (exifInfoState !== undefined) {
                localVarQueryParameter['exifInfo.state'] = exifInfoState;
            }

            if (exifInfoCountry !== undefined) {
                localVarQueryParameter['exifInfo.country'] = exifInfoCountry;
            }

            if (exifInfoMake !== undefined) {
                localVarQueryParameter['exifInfo.make'] = exifInfoMake;
            }

            if (exifInfoModel !== undefined) {
                localVarQueryParameter['exifInfo.model'] = exifInfoModel;
            }

            if (smartInfoObjects) {
                localVarQueryParameter['smartInfo.objects'] = smartInfoObjects;
            }

            if (smartInfoTags) {
                localVarQueryParameter['smartInfo.tags'] = smartInfoTags;
            }

            if (recent !== undefined) {
                localVarQueryParameter['recent'] = recent;
            }

            if (motion !== undefined) {
                localVarQueryParameter['motion'] = motion;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchApi - functional programming interface
 * @export
 */
export const SearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SearchApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExploreData(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SearchExploreResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExploreData(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSearchConfig(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchConfigResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSearchConfig(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [q] 
         * @param {string} [query] 
         * @param {boolean} [clip] 
         * @param {'IMAGE' | 'VIDEO' | 'AUDIO' | 'OTHER'} [type] 
         * @param {boolean} [isFavorite] 
         * @param {string} [exifInfoCity] 
         * @param {string} [exifInfoState] 
         * @param {string} [exifInfoCountry] 
         * @param {string} [exifInfoMake] 
         * @param {string} [exifInfoModel] 
         * @param {Array<string>} [smartInfoObjects] 
         * @param {Array<string>} [smartInfoTags] 
         * @param {boolean} [recent] 
         * @param {boolean} [motion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async search(q?: string, query?: string, clip?: boolean, type?: 'IMAGE' | 'VIDEO' | 'AUDIO' | 'OTHER', isFavorite?: boolean, exifInfoCity?: string, exifInfoState?: string, exifInfoCountry?: string, exifInfoMake?: string, exifInfoModel?: string, smartInfoObjects?: Array<string>, smartInfoTags?: Array<string>, recent?: boolean, motion?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.search(q, query, clip, type, isFavorite, exifInfoCity, exifInfoState, exifInfoCountry, exifInfoMake, exifInfoModel, smartInfoObjects, smartInfoTags, recent, motion, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SearchApi - factory interface
 * @export
 */
export const SearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SearchApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExploreData(options?: any): AxiosPromise<Array<SearchExploreResponseDto>> {
            return localVarFp.getExploreData(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSearchConfig(options?: any): AxiosPromise<SearchConfigResponseDto> {
            return localVarFp.getSearchConfig(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [q] 
         * @param {string} [query] 
         * @param {boolean} [clip] 
         * @param {'IMAGE' | 'VIDEO' | 'AUDIO' | 'OTHER'} [type] 
         * @param {boolean} [isFavorite] 
         * @param {string} [exifInfoCity] 
         * @param {string} [exifInfoState] 
         * @param {string} [exifInfoCountry] 
         * @param {string} [exifInfoMake] 
         * @param {string} [exifInfoModel] 
         * @param {Array<string>} [smartInfoObjects] 
         * @param {Array<string>} [smartInfoTags] 
         * @param {boolean} [recent] 
         * @param {boolean} [motion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(q?: string, query?: string, clip?: boolean, type?: 'IMAGE' | 'VIDEO' | 'AUDIO' | 'OTHER', isFavorite?: boolean, exifInfoCity?: string, exifInfoState?: string, exifInfoCountry?: string, exifInfoMake?: string, exifInfoModel?: string, smartInfoObjects?: Array<string>, smartInfoTags?: Array<string>, recent?: boolean, motion?: boolean, options?: any): AxiosPromise<SearchResponseDto> {
            return localVarFp.search(q, query, clip, type, isFavorite, exifInfoCity, exifInfoState, exifInfoCountry, exifInfoMake, exifInfoModel, smartInfoObjects, smartInfoTags, recent, motion, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SearchApi - object-oriented interface
 * @export
 * @class SearchApi
 * @extends {BaseAPI}
 */
export class SearchApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public getExploreData(options?: AxiosRequestConfig) {
        return SearchApiFp(this.configuration).getExploreData(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public getSearchConfig(options?: AxiosRequestConfig) {
        return SearchApiFp(this.configuration).getSearchConfig(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [q] 
     * @param {string} [query] 
     * @param {boolean} [clip] 
     * @param {'IMAGE' | 'VIDEO' | 'AUDIO' | 'OTHER'} [type] 
     * @param {boolean} [isFavorite] 
     * @param {string} [exifInfoCity] 
     * @param {string} [exifInfoState] 
     * @param {string} [exifInfoCountry] 
     * @param {string} [exifInfoMake] 
     * @param {string} [exifInfoModel] 
     * @param {Array<string>} [smartInfoObjects] 
     * @param {Array<string>} [smartInfoTags] 
     * @param {boolean} [recent] 
     * @param {boolean} [motion] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public search(q?: string, query?: string, clip?: boolean, type?: 'IMAGE' | 'VIDEO' | 'AUDIO' | 'OTHER', isFavorite?: boolean, exifInfoCity?: string, exifInfoState?: string, exifInfoCountry?: string, exifInfoMake?: string, exifInfoModel?: string, smartInfoObjects?: Array<string>, smartInfoTags?: Array<string>, recent?: boolean, motion?: boolean, options?: AxiosRequestConfig) {
        return SearchApiFp(this.configuration).search(q, query, clip, type, isFavorite, exifInfoCity, exifInfoState, exifInfoCountry, exifInfoMake, exifInfoModel, smartInfoObjects, smartInfoTags, recent, motion, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ServerInfoApi - axios parameter creator
 * @export
 */
export const ServerInfoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerInfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/server-info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerVersion: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/server-info/version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/server-info/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pingServer: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/server-info/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServerInfoApi - functional programming interface
 * @export
 */
export const ServerInfoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServerInfoApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServerInfo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerInfoResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServerInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServerVersion(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerVersionReponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServerVersion(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStats(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerStatsResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStats(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pingServer(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerPingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pingServer(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ServerInfoApi - factory interface
 * @export
 */
export const ServerInfoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServerInfoApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerInfo(options?: any): AxiosPromise<ServerInfoResponseDto> {
            return localVarFp.getServerInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerVersion(options?: any): AxiosPromise<ServerVersionReponseDto> {
            return localVarFp.getServerVersion(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats(options?: any): AxiosPromise<ServerStatsResponseDto> {
            return localVarFp.getStats(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pingServer(options?: any): AxiosPromise<ServerPingResponse> {
            return localVarFp.pingServer(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServerInfoApi - object-oriented interface
 * @export
 * @class ServerInfoApi
 * @extends {BaseAPI}
 */
export class ServerInfoApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerInfoApi
     */
    public getServerInfo(options?: AxiosRequestConfig) {
        return ServerInfoApiFp(this.configuration).getServerInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerInfoApi
     */
    public getServerVersion(options?: AxiosRequestConfig) {
        return ServerInfoApiFp(this.configuration).getServerVersion(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerInfoApi
     */
    public getStats(options?: AxiosRequestConfig) {
        return ServerInfoApiFp(this.configuration).getStats(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerInfoApi
     */
    public pingServer(options?: AxiosRequestConfig) {
        return ServerInfoApiFp(this.configuration).pingServer(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ShareApi - axios parameter creator
 * @export
 */
export const ShareApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {EditSharedLinkDto} editSharedLinkDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editSharedLink: async (id: string, editSharedLinkDto: EditSharedLinkDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('editSharedLink', 'id', id)
            // verify required parameter 'editSharedLinkDto' is not null or undefined
            assertParamExists('editSharedLink', 'editSharedLinkDto', editSharedLinkDto)
            const localVarPath = `/share/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editSharedLinkDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSharedLinks: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/share`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMySharedLink: async (key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/share/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedLinkById: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSharedLinkById', 'id', id)
            const localVarPath = `/share/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSharedLink: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('removeSharedLink', 'id', id)
            const localVarPath = `/share/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ShareApi - functional programming interface
 * @export
 */
export const ShareApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ShareApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {EditSharedLinkDto} editSharedLinkDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editSharedLink(id: string, editSharedLinkDto: EditSharedLinkDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SharedLinkResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editSharedLink(id, editSharedLinkDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllSharedLinks(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SharedLinkResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllSharedLinks(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMySharedLink(key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SharedLinkResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMySharedLink(key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSharedLinkById(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SharedLinkResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSharedLinkById(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeSharedLink(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeSharedLink(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ShareApi - factory interface
 * @export
 */
export const ShareApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ShareApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {EditSharedLinkDto} editSharedLinkDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editSharedLink(id: string, editSharedLinkDto: EditSharedLinkDto, options?: any): AxiosPromise<SharedLinkResponseDto> {
            return localVarFp.editSharedLink(id, editSharedLinkDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSharedLinks(options?: any): AxiosPromise<Array<SharedLinkResponseDto>> {
            return localVarFp.getAllSharedLinks(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMySharedLink(key?: string, options?: any): AxiosPromise<SharedLinkResponseDto> {
            return localVarFp.getMySharedLink(key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedLinkById(id: string, options?: any): AxiosPromise<SharedLinkResponseDto> {
            return localVarFp.getSharedLinkById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSharedLink(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeSharedLink(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ShareApi - object-oriented interface
 * @export
 * @class ShareApi
 * @extends {BaseAPI}
 */
export class ShareApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {EditSharedLinkDto} editSharedLinkDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    public editSharedLink(id: string, editSharedLinkDto: EditSharedLinkDto, options?: AxiosRequestConfig) {
        return ShareApiFp(this.configuration).editSharedLink(id, editSharedLinkDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    public getAllSharedLinks(options?: AxiosRequestConfig) {
        return ShareApiFp(this.configuration).getAllSharedLinks(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    public getMySharedLink(key?: string, options?: AxiosRequestConfig) {
        return ShareApiFp(this.configuration).getMySharedLink(key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    public getSharedLinkById(id: string, options?: AxiosRequestConfig) {
        return ShareApiFp(this.configuration).getSharedLinkById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    public removeSharedLink(id: string, options?: AxiosRequestConfig) {
        return ShareApiFp(this.configuration).removeSharedLink(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SystemConfigApi - axios parameter creator
 * @export
 */
export const SystemConfigApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfig: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/system-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaults: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/system-config/defaults`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorageTemplateOptions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/system-config/storage-template-options`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SystemConfigDto} systemConfigDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConfig: async (systemConfigDto: SystemConfigDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'systemConfigDto' is not null or undefined
            assertParamExists('updateConfig', 'systemConfigDto', systemConfigDto)
            const localVarPath = `/system-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(systemConfigDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemConfigApi - functional programming interface
 * @export
 */
export const SystemConfigApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SystemConfigApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConfig(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemConfigDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConfig(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDefaults(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemConfigDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDefaults(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStorageTemplateOptions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemConfigTemplateStorageOptionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStorageTemplateOptions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SystemConfigDto} systemConfigDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateConfig(systemConfigDto: SystemConfigDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemConfigDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateConfig(systemConfigDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SystemConfigApi - factory interface
 * @export
 */
export const SystemConfigApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SystemConfigApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfig(options?: any): AxiosPromise<SystemConfigDto> {
            return localVarFp.getConfig(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaults(options?: any): AxiosPromise<SystemConfigDto> {
            return localVarFp.getDefaults(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorageTemplateOptions(options?: any): AxiosPromise<SystemConfigTemplateStorageOptionDto> {
            return localVarFp.getStorageTemplateOptions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SystemConfigDto} systemConfigDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConfig(systemConfigDto: SystemConfigDto, options?: any): AxiosPromise<SystemConfigDto> {
            return localVarFp.updateConfig(systemConfigDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SystemConfigApi - object-oriented interface
 * @export
 * @class SystemConfigApi
 * @extends {BaseAPI}
 */
export class SystemConfigApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemConfigApi
     */
    public getConfig(options?: AxiosRequestConfig) {
        return SystemConfigApiFp(this.configuration).getConfig(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemConfigApi
     */
    public getDefaults(options?: AxiosRequestConfig) {
        return SystemConfigApiFp(this.configuration).getDefaults(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemConfigApi
     */
    public getStorageTemplateOptions(options?: AxiosRequestConfig) {
        return SystemConfigApiFp(this.configuration).getStorageTemplateOptions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SystemConfigDto} systemConfigDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemConfigApi
     */
    public updateConfig(systemConfigDto: SystemConfigDto, options?: AxiosRequestConfig) {
        return SystemConfigApiFp(this.configuration).updateConfig(systemConfigDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TagApi - axios parameter creator
 * @export
 */
export const TagApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('_delete', 'id', id)
            const localVarPath = `/tag/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateTagDto} createTagDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (createTagDto: CreateTagDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTagDto' is not null or undefined
            assertParamExists('create', 'createTagDto', createTagDto)
            const localVarPath = `/tag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTagDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOne: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findOne', 'id', id)
            const localVarPath = `/tag/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateTagDto} updateTagDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (id: string, updateTagDto: UpdateTagDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update', 'id', id)
            // verify required parameter 'updateTagDto' is not null or undefined
            assertParamExists('update', 'updateTagDto', updateTagDto)
            const localVarPath = `/tag/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTagDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagApi - functional programming interface
 * @export
 */
export const TagApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CreateTagDto} createTagDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(createTagDto: CreateTagDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(createTagDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TagResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findOne(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findOne(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateTagDto} updateTagDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(id: string, updateTagDto: UpdateTagDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(id, updateTagDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TagApi - factory interface
 * @export
 */
export const TagApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp._delete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateTagDto} createTagDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(createTagDto: CreateTagDto, options?: any): AxiosPromise<TagResponseDto> {
            return localVarFp.create(createTagDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAll(options?: any): AxiosPromise<Array<TagResponseDto>> {
            return localVarFp.findAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOne(id: string, options?: any): AxiosPromise<TagResponseDto> {
            return localVarFp.findOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateTagDto} updateTagDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(id: string, updateTagDto: UpdateTagDto, options?: any): AxiosPromise<TagResponseDto> {
            return localVarFp.update(id, updateTagDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TagApi - object-oriented interface
 * @export
 * @class TagApi
 * @extends {BaseAPI}
 */
export class TagApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public _delete(id: string, options?: AxiosRequestConfig) {
        return TagApiFp(this.configuration)._delete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateTagDto} createTagDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public create(createTagDto: CreateTagDto, options?: AxiosRequestConfig) {
        return TagApiFp(this.configuration).create(createTagDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public findAll(options?: AxiosRequestConfig) {
        return TagApiFp(this.configuration).findAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public findOne(id: string, options?: AxiosRequestConfig) {
        return TagApiFp(this.configuration).findOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateTagDto} updateTagDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public update(id: string, updateTagDto: UpdateTagDto, options?: AxiosRequestConfig) {
        return TagApiFp(this.configuration).update(id, updateTagDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {any} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProfileImage: async (file: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('createProfileImage', 'file', file)
            const localVarPath = `/user/profile-image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (createUserDto: CreateUserDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createUserDto' is not null or undefined
            assertParamExists('createUser', 'createUserDto', createUserDto)
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUser', 'userId', userId)
            const localVarPath = `/user/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} isAll 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers: async (isAll: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'isAll' is not null or undefined
            assertParamExists('getAllUsers', 'isAll', isAll)
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required

            if (isAll !== undefined) {
                localVarQueryParameter['isAll'] = isAll;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyUserInfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfileImage: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getProfileImage', 'userId', userId)
            const localVarPath = `/user/profile-image/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserById', 'userId', userId)
            const localVarPath = `/user/info/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} [admin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCount: async (admin?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (admin !== undefined) {
                localVarQueryParameter['admin'] = admin;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreUser: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('restoreUser', 'userId', userId)
            const localVarPath = `/user/{userId}/restore`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (updateUserDto: UpdateUserDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateUserDto' is not null or undefined
            assertParamExists('updateUser', 'updateUserDto', updateUserDto)
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {any} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProfileImage(file: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateProfileImageResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProfileImage(file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(createUserDto: CreateUserDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(createUserDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {boolean} isAll 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllUsers(isAll: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllUsers(isAll, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMyUserInfo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMyUserInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfileImage(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProfileImage(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserById(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserById(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {boolean} [admin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserCount(admin?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCountResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserCount(admin, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreUser(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreUser(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(updateUserDto: UpdateUserDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(updateUserDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @param {any} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProfileImage(file: any, options?: any): AxiosPromise<CreateProfileImageResponseDto> {
            return localVarFp.createProfileImage(file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(createUserDto: CreateUserDto, options?: any): AxiosPromise<UserResponseDto> {
            return localVarFp.createUser(createUserDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(userId: string, options?: any): AxiosPromise<UserResponseDto> {
            return localVarFp.deleteUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} isAll 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers(isAll: boolean, options?: any): AxiosPromise<Array<UserResponseDto>> {
            return localVarFp.getAllUsers(isAll, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyUserInfo(options?: any): AxiosPromise<UserResponseDto> {
            return localVarFp.getMyUserInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfileImage(userId: string, options?: any): AxiosPromise<object> {
            return localVarFp.getProfileImage(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById(userId: string, options?: any): AxiosPromise<UserResponseDto> {
            return localVarFp.getUserById(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} [admin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCount(admin?: boolean, options?: any): AxiosPromise<UserCountResponseDto> {
            return localVarFp.getUserCount(admin, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreUser(userId: string, options?: any): AxiosPromise<UserResponseDto> {
            return localVarFp.restoreUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(updateUserDto: UpdateUserDto, options?: any): AxiosPromise<UserResponseDto> {
            return localVarFp.updateUser(updateUserDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @param {any} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public createProfileImage(file: any, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).createProfileImage(file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateUserDto} createUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public createUser(createUserDto: CreateUserDto, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).createUser(createUserDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public deleteUser(userId: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).deleteUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {boolean} isAll 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getAllUsers(isAll: boolean, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getAllUsers(isAll, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getMyUserInfo(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getMyUserInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getProfileImage(userId: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getProfileImage(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserById(userId: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserById(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {boolean} [admin] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserCount(admin?: boolean, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserCount(admin, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public restoreUser(userId: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).restoreUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateUserDto} updateUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUser(updateUserDto: UpdateUserDto, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).updateUser(updateUserDto, options).then((request) => request(this.axios, this.basePath));
    }
}


